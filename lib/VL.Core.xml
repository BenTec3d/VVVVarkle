<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.Core</name>
    </assembly>
    <members>
        <member name="T:VL.App.AppHost">
            <summary>
            Encapsulates all the platform independent logic to run a VL app.
            </summary>
        </member>
        <member name="T:VL.Core.CompilerServices.CollectionBuilders">
            <summary>
            These builders are used by the target code for pin groups and ouput splicers.
            </summary>
        </member>
        <member name="T:VL.Core.CompilerServices.PrivateImplAttribute">
            <summary>
            Gets attached to private VL object implementations.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.TracingId">
            <summary>
            The element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.PersistentId">
            <summary>
            The persistent element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsAutoGenerated">
            <summary>
            Whether or not the element was auto generated by the compiler.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsImmutable">
            <summary>
            Whether or not the type is immutable.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsManaged">
            <summary>
            Whether or not the field will be disposed when it goes out of scope during a hotswap.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.Name">
            <summary>
            The name of the element. This is set in case the compiler generated name differs from the one set in VL.
            </summary>
        </member>
        <member name="T:VL.Core.EventBridge">
            <summary>
            Contains helper functions to turn .NET events into observables.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="T:VL.Core.INotifyHotSwapped">
            <summary>
            Allows objects to get notified when they've been hot swapped.
            </summary>
        </member>
        <member name="M:VL.Core.INotifyHotSwapped.SwappedOut(System.Object)">
            <summary>
            Called after this instance has been removed from the runtime graph.
            </summary>
        </member>
        <member name="M:VL.Core.INotifyHotSwapped.SwappedIn(System.Object)">
            <summary>
            Called after this instance has been added to the runtime graph.
            </summary>
            <param name="oldInstance"></param>
        </member>
        <member name="T:VL.Core.HotSwapAttribute">
            <summary>
            Forces the hot swapper to call the constructor of this type and only swap fields which also have this attribute set.
            </summary>
        </member>
        <member name="T:VL.Core.InitializationException">
            <summary>
            Thrown in case initialization code fails.
            </summary>
        </member>
        <member name="T:VL.Core.IInfo">
            <summary>
            Implement this interface to provide a summary and remarks.
            </summary>
        </member>
        <member name="P:VL.Core.IInfo.Summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="P:VL.Core.IInfo.Remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="T:VL.Core.ITaggedInfo">
            <summary>
            Implement this interface to provide tags the node browser can use to find stuff.
            </summary>
        </member>
        <member name="P:VL.Core.ITaggedInfo.Tags">
            <summary>
            For being bale to find the entity.
            </summary>
        </member>
        <member name="T:VL.Core.IVLNodeDescriptionFactory">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="P:VL.Core.ExportContext.ProjectRootElement">
            <summary>
            The Microsoft.Build.Construction.ProjectRootElement which represent the MSBuild project.
            The property is typed as object to avoid a runtime dependency on MSBuild.
            Should the factory code do indeed need to interact with the project it needs to ensure that
            the method doing the cast will trigger a type load exception should MSBuild not be present (for example if a patch was exported).
            For details see https://github.com/microsoft/MSBuildLocator
            </summary>
        </member>
        <member name="P:VL.Core.ExportContext.DirectoryPath">
            <summary>
            The directory that the project being generated is in.
            </summary>
        </member>
        <member name="T:VL.Core.IVLNodeDescription">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="P:VL.Core.IVLNodeDescription.Fragmented">
            <summary>
            Whether the system shall create getter and setter fragments for each pin. 
            The first getter will also be marked as the default fragment.
            </summary>
        </member>
        <member name="T:VL.Core.IVLPinDescription">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLNode">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLPin">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLPin`1">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLObject">
            <summary>
            Non-generic interface implemented by VL emitted classes and records.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Context">
            <summary>
            The context in which this instance was created.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Type">
            <summary>
            The type of the object.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Identity">
            <summary>
            The unique identity of the object. Gets preserved for immutable types.
            </summary>
        </member>
        <member name="T:VL.Core.IVLRuntime">
            <summary>
            Interface to interact with the VL runtime.
            </summary>
        </member>
        <member name="P:VL.Core.IVLRuntime.IsRunning">
            <summary>
            Whether or not VL is in a running state. If not calls into its object graph are not allowed.
            </summary>
        </member>
        <member name="T:VL.Core.IVLFactory">
            <summary>
            Interface to create VL objects.
            </summary>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeByName(System.String)">
            <summary>
            Lookup a type by name. The name will be parsed based on the usual VL type annotation rules.
            For example "Integer32" or "Spread [Collections] &lt;Float32&gt;".
            </summary>
            <param name="name">The name of the type.</param>
            <returns>The first type which matches the name or null.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeInfo(System.Type)">
            <summary>
            Fetch the VL type info for a given CLR type.
            </summary>
            <param name="type">The CLR type to fetch the VL type info for.</param>
            <returns>The VL type info wrapping the given CLR type.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.IsKnownType(System.Type)">
            <summary>
            Whether or not the given CLR type is known to the factory. Only type as seen by the compiler are considered to be known types.
            </summary>
            <param name="type">The type in question.</param>
            <returns>True if the type is known to the VL compiler.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.CreateInstance(System.Type,VL.Core.NodeContext,System.Type)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="type">The type to create a new instance of.</param>
            <param name="nodeContext">The context to use when creating the instance.</param>
            <param name="witness">The witness to use for the CreateNew call.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetDefaultValue(System.Type,System.Type)">
            <summary>
            Returns the default value of the given type as defined by VL through the CreateDefault operations.
            </summary>
            <param name="type">The type to return the default value of.</param>
            <param name="witness">The witness to use for the CreateDefault call.</param>
            <returns>The default value of the given type as defined by VL or null if the type is not known to VL or no default has been defined.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.RegisterService(System.Type,System.Type,System.Func{System.Object,System.Object})">
            <summary>
            Registers a factory function which gets invoked when a certain service of type <paramref name="serviceType"/> is requested for
            a specific value of type <paramref name="forType"/>. The factory function must return a service of the specified <paramref name="serviceType"/>.
            </summary>
            <param name="forType">The type of the value for which a service will be requested.</param>
            <param name="serviceType">The type of the service.</param>
            <param name="serviceFactory">The factory function creating such a service.</param>
        </member>
        <member name="M:VL.Core.IVLFactory.GetServiceFactory(System.Type,System.Type)">
            <summary>
            Retrieves the factory function which will create the service of type <paramref name="serviceType"/> for the given <paramref name="forType"/>.
            </summary>
            <param name="forType">The type of the value for which a service is requested.</param>
            <param name="serviceType">The type of the service.</param>
            <returns>The factory function creating the service or null.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.RegisterType(System.Type,System.String,System.String,System.Type)">
            <summary>
            Registers a type to the factory. It's intended use is for the compiler only.
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="category"></param>
            <param name="container"></param>
        </member>
        <member name="T:VL.Core.IVLTypeInfo">
            <summary>
            Interface to interact with VL types.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Category">
            <summary>
            The category of the type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.FullName">
            <summary>
            The full name of the type. For example "Integer32 [Primitive]" or "Spread [Collections] &lt;Float32 [Primitive]&gt;".
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.ClrType">
            <summary>
            The CLR type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsPatched">
            <summary>
            Whether or not this type is a patched VL type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsClass">
            <summary>
            Whether or not this type is a VL class (mutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsRecord">
            <summary>
            Whether or not this type is a VL record (immutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Properties">
            <summary>
            The user defined properties of this type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.AllProperties">
            <summary>
            The user defined and system generated properties of this type.
            </summary>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.GetProperty(System.String)">
            <summary>
            Returns the property with the given name.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>The property or null.</returns>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.ToString(System.Boolean)">
            <summary>
            Returns a string representation of this type.
            </summary>
            <param name="includeCategory">Whether or not to include the category.</param>
            <returns>The string representation of this type.</returns>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.CreateInstance(VL.Core.NodeContext,System.Type)">
            <summary>
            Create a new instance of this type by calling it's constructor using default values for any of its arguments.
            If there's no default constructor registered for this type it will fallback to the default value.
            </summary>
            <param name="context">The node context to use. Used by patched types.</param>
            <param name="witness">The witness to use for the CreateNew call.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.GetDefaultValue(System.Type)">
            <summary>
            Retrieves the default value of this type. 
            If there's no default value registered for this type it will return the CLR default.
            </summary>
            <param name="witness">The witness to use for the CreateDefault call.</param>
            <returns>The default of this type.</returns>
        </member>
        <member name="T:VL.Core.IVLPropertyInfo">
            <summary>
            Interface to interact with VL properties.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.DeclaringType">
            <summary>
            The type which declared this property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Id">
            <summary>
            The id of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Name">
            <summary>
            The name of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Type">
            <summary>
            The type of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.IsManaged">
            <summary>
            Whether or not the property is system generated.
            </summary>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.GetValue(VL.Core.IVLObject)">
            <summary>
            Gets the property value of the given instance.
            </summary>
            <param name="instance">The instance to get the value from.</param>
            <returns>The value of the property.</returns>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.WithValue(VL.Core.IVLObject,System.Object)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <param name="instance">The instance to set the value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the newly set value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.GetDefaultValue``1(VL.Core.IVLFactory)">
            <summary>
            Returns the VL defined default value for the given type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type for which to return the VL defined default value.</typeparam>
            <param name="factory">The factory to use to create the default value.</param>
            <returns>The VL defined default value of the given type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateInstance``1(VL.Core.IVLFactory,``0,VL.Core.NodeContext,``0@)">
            <summary>
            Tries to create an instance of the given type <typeparamref name="T"/> using the VL generated constructor.
            Returns true in case an instance was created.
            </summary>
            <typeparam name="T">The type of which to create an instance for.</typeparam>
            <param name="factory">The factory which will create the instance.</param>
            <param name="defaultValue">The default value to use in case an instance couldn't be created.</param>
            <param name="nodeContext">The context in which the new instance will be created.</param>
            <param name="instance">The newly created instance or the given default value.</param>
            <returns>True in case a new instance was created.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type,System.UInt32)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo,System.UInt32)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.RegisterService``2(VL.Core.IVLFactory,System.Func{``0,``1})">
            <summary>
            Registers a factory function which gets invoked when a service of type <typeparamref name="TService"/> is requested for
            a value of type <typeparamref name="TForType"/>.
            </summary>
            <typeparam name="TForType">The type of the value for which a service will be requested.</typeparam>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory to register the service in.</param>
            <param name="create">The factory function to invoke when such a service is requested.</param>
            <returns>The factory with the registered service.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.RegisterService``1(VL.Core.IVLFactory,``0)">
            <summary>
            Registers a factory function which gets invoked when a service of type <typeparamref name="TService"/> is requested.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory to register the service in.</param>
            <param name="service">The service to register.</param>
            <returns>The factory with the registered service.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateService``1(VL.Core.IVLFactory,System.Object)">
            <summary>
            Creates a service of the given type <typeparamref name="TService"/> for the given value.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered for the type of the value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.GetService``1(VL.Core.IVLFactory)">
            <summary>
            Gets the service type <typeparamref name="TService"/> or null.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which contains the service.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateServiceSafe``1(VL.Core.IVLFactory,System.Object)">
            <summary>
            Creates a service of the given type <typeparamref name="TService"/> for the given value. returns default if creating the service failed.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered for the type of the value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateService``1(VL.Core.IVLFactory,System.Object,``0,``0@)">
            <summary>
            Tries to create a service of the given type <typeparamref name="TService"/> for the given value.
            Returns true if such a service was found for the given value, otherwise the given default service will be used.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <param name="defaultService">The default service to use in case no service of that type was registered for the type of the value.</param>
            <param name="service">The registered service or the given default service.</param>
            <returns>True in case a service was found and created.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValue``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given property.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The instance to retrieve the value from.</param>
            <param name="name">The name of the property.</param>
            <param name="defaultValue">The default value to use in case retrieval failed.</param>
            <param name="value">The returned values.</param>
            <returns>True if the retrieval succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValue``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given property and returns a new instance (if it is a record) with the set value.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="instance">The instance to set the property value on.</param>
            <param name="name">The name of the property.</param>
            <param name="value">The value to set.</param>
            <returns>The new instance (if it is a record) with the set value.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValueByPath``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" retrieves the first value in MySpread.</param>
            <param name="defaultValue">The default value to use in case the lookup failed.</param>
            <param name="value">The returned value.</param>
            <returns>True if the lookup succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValueByPath``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" sets the first value in MySpread.</param>
            <param name="value">The value to set.</param>
            <returns>The new root instance (if it is a record) with the updated spine.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryReplaceDescendant``2(``0,``1,``0@)">
            <summary>
            Traverses into the object graph of <paramref name="instance"/> and if it can find a descendant with the same <see cref="P:VL.Core.IVLObject.Identity"/>
            as the given <paramref name="descendant"/> replaces it and outputs a new <paramref name="updatedInstance"/>.
            </summary>
            <remarks>
            Only user defined properties will be traversed. If a property holds many children it must be of type <see cref="T:VL.Lib.Collections.ISpread"/>. Other collection types will not be looked at.
            </remarks>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TDescendant">The type of the descendant.</typeparam>
            <param name="instance">The instance to traverse into.</param>
            <param name="descendant">The new descendant.</param>
            <param name="updatedInstance">The updated instance with the descendant replaced.</param>
            <returns>Returns true if a descendant with the same <see cref="P:VL.Core.IVLObject.Identity"/> as the given one was found and replaced.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.TryGetValue``1(VL.Core.IVLPropertyInfo,VL.Core.IVLObject,``0,``0@)">
            <summary>
            Tries to get the property value of the given instance.
            </summary>
            <typeparam name="T">The expected type of the property value.</typeparam>
            <param name="property">The property to read.</param>
            <param name="instance">The instance to get the property value from.</param>
            <param name="defaultValue">The value to return in case retrieval failed.</param>
            <param name="value">The retrieved property value.</param>
            <returns>Whether or not the operation succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.WithValue``2(VL.Core.IVLPropertyInfo,``0,``1)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="property">The property to write.</param>
            <param name="instance">The instance to set the property value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the set value.</returns>
        </member>
        <member name="P:VL.Core.IMainLoopTimer.Interval">
            <summary>
            Gets or sets the desired interval. This is the minimum time that has to pass between two frame ticks.
            Default is 1/60 of a second.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:VL.Core.IMainLoopTimer.WaitAccuracy" -->
        <member name="P:VL.Core.IMainLoopTimer.IsIncremental">
            <summary>
            Enables fixed increment time mode.
            </summary>
        </member>
        <member name="P:VL.Core.IMainLoopTimer.Increment">
            <summary>
            Gets or sets the time increment. Used when <see cref="P:VL.Core.IMainLoopTimer.IsIncremental"/> is set to true.
            </summary>
        </member>
        <member name="P:VL.Core.IMainLoopTimer.LastInterval">
            <summary>
            The time interval between the last frame and the current frame.
            </summary>
        </member>
        <member name="T:VL.Core.MainloopTimer">
            <summary>
            Timer using the busy wait method on a new thread, extremely accurate but uses a bit of CPU.
            </summary>
        </member>
        <member name="E:VL.Core.MainloopTimer.Started">
            <summary>
            Occurs when the Timer has started.
            </summary>
        </member>
        <member name="E:VL.Core.MainloopTimer.Tick">
            <summary>
            Occurs when the Timer has completed one interval.
            </summary>
        </member>
        <member name="E:VL.Core.MainloopTimer.Stopped">
            <summary>
            Occurs when the Timer has stopped.
            </summary>
        </member>
        <member name="M:VL.Core.MainloopTimer.#ctor(System.Diagnostics.Stopwatch)">
            <summary>
            Initializes a new instance of the Timer class.
            </summary>
        </member>
        <member name="M:VL.Core.MainloopTimer.Start">
            <summary>
            Starts the timer.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The timer has already been disposed.
            </exception>
        </member>
        <member name="M:VL.Core.MainloopTimer.StartIdle">
            <summary>
            Starts the timer.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The timer has already been disposed.
            </exception>
        </member>
        <member name="M:VL.Core.MainloopTimer.UpdateFrameCounter">
            <summary>
            Increase the frame counter.
            </summary>
        </member>
        <member name="M:VL.Core.MainloopTimer.Stop">
            <summary>
            Stops timer.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            If the timer has already been disposed.
            </exception>
        </member>
        <member name="P:VL.Core.MainloopTimer.Interval">
            <summary>
            Gets or sets the time between Tick events.
            </summary>
        </member>
        <member name="P:VL.Core.MainloopTimer.Mode">
            <summary>
            Gets the timer mode.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            If the timer has already been disposed.
            </exception>
        </member>
        <member name="P:VL.Core.MainloopTimer.Increment">
            <summary>
            Gets or sets the time increment. Used when <see cref="P:VL.Core.MainloopTimer.IsIncremental"/> is set to true.
            </summary>
        </member>
        <member name="P:VL.Core.MainloopTimer.IsRunning">
            <summary>
            Gets a value indicating whether the Timer is running.
            </summary>
        </member>
        <member name="P:VL.Core.MainloopTimer.Now">
            <summary>
            Returns the time since the timer was created.
            Internally uses the .NET Stopwatch.
            </summary>
        </member>
        <member name="M:VL.Core.MainloopTimer.Dispose">
            <summary>
            Frees timer resources.
            </summary>
        </member>
        <member name="T:VL.Core.TimerMode">
            <summary>
            Defines constants for the Timer's event types
            </summary>
        </member>
        <member name="F:VL.Core.TimerMode.OneShot">
            <summary>
            Timer event occurs once.
            </summary>
        </member>
        <member name="F:VL.Core.TimerMode.Periodic">
            <summary>
            Timer event occurs periodically.
            </summary>
        </member>
        <member name="T:VL.Core.TimeSpanUtils">
            <summary>
            Creates TimeSpans in a precise way, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.TimeSpanUtils.FromMillisecondsPrecise(System.Double)">
            <summary>
            Creates a TimeSpan with precise tick count, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.TimeSpanUtils.FromSecondsPrecise(System.Double)">
            <summary>
            Creates a TimeSpan with precise tick count, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.TimeSpanUtils.FromMinutesPrecise(System.Double)">
            <summary>
            Creates a TimeSpan with precise tick count, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.WindowsMessageUtils.DoEvents">
            <summary>
            Process all messages in the queue.
            </summary>
            <returns>True if the WM_QUIT or WM_DESTROY message occured</returns>
        </member>
        <member name="T:VL.Core.WindowsTimerUtils">
            <summary>
            Description of WinApiCalls.
            </summary>
        </member>
        <member name="T:VL.Core.NodeContext">
            <summary>
            Contains information about the environment in which a node was created.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Default">
            <summary>
            The default context.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.Create(System.UInt32,VL.Core.IVLFactory,System.Boolean)">
            <summary>
            Creates a new root context.
            </summary>
            <param name="rootId">The root id.</param>
            <param name="factory">The VL factory.</param>
            <param name="isImmutable">Whether the context is immutable.</param>
            <returns>The new root context.</returns>
        </member>
        <member name="M:VL.Core.NodeContext.#ctor(System.Collections.Immutable.ImmutableStack{System.UInt32},VL.Core.IVLFactory,System.Boolean)">
            <summary>
            Creates a new context.
            </summary>
            <param name="path">The path to the node for which this context gets created.</param>
            <param name="factory">The VL factory.</param>
            <param name="isImmutable">Whether the context must be immutable.</param>
        </member>
        <member name="F:VL.Core.NodeContext.Path">
            <summary>
            The path to the node.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.IsImmutable">
            <summary>
            Whether or not the context is immutable. In an immutable context the state must not be modified.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.CreateSubContext(System.UInt32)">
            <summary>
            Creates a new sub context.
            </summary>
        </member>
        <member name="P:VL.Core.NodeFactoryRegistry.Paths">
            <summary>
            The registered paths. Each registered node factory can produce additional factories per path.
            </summary>
        </member>
        <member name="T:VL.Core.RuntimeGraph">
            <summary>
            A collection of methods used by nodes which introduce new entry points into the VL runtime graph.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Enter">
            <summary>
            Call when entering the VL runtime graph from a background thread.
            </summary>
            <returns>A disposable that releases the lock when disposed.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.EnterAsync">
            <summary>
            Call when entering the VL runtime graph from a main thread. Do NOT use it from a background thread as it would spawn many new tasks over time
            if another background task takes a long time to complete.
            </summary>
            <returns>A disposable that releases the lock when disposed.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Pause(System.Threading.CancellationToken)">
            <summary>
            Stops instances from entering the VL runtime graph.
            </summary>
            <param name="cancellationToken">The cancellation token used to cancel the lock.</param>
            <returns>A disposable that releases the lock when disposed.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.HandleException">
            <summary>
            If an exception is set it will be unset and thrown in an aggregate exception.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.ReportException(System.Exception)">
            <summary>
            The exception to throw by the HandleAsyncException call.
            </summary>
            <param name="exception">The exception to report.</param>
        </member>
        <member name="T:VL.Core.ISerializer`1">
            <summary>
            The serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="M:VL.Core.ISerializer`1.Serialize(VL.Core.SerializationContext,`0)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.ISerializer`1.Deserialize(VL.Core.SerializationContext,System.Object,System.Type)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="type">The type of the deserialized value.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="T:VL.Core.SerializationContext">
            <summary>
            The serialization context.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.#ctor(VL.Core.IVLFactory,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Creates a new serialization context.
            </summary>
            <param name="factory">The VL factory.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
            <param name="version">The version of the serialization format.</param>
        </member>
        <member name="P:VL.Core.SerializationContext.Version">
            <summary>
            The version of the serialization format.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.ThrowOnError">
            <summary>
            Whether or not serialization error should lead to an exception
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.IncludeDefaults">
            <summary>
            Whether or not default values will also be serialized.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.Errors">
            <summary>
            The accumulated error messages.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.ReportError(System.String)">
            <summary>
            Reports an error. Will throw a <see cref="T:VL.Core.SerializationException"/> in case <see cref="P:VL.Core.SerializationContext.ThrowOnError"/> is enabled.
            </summary>
            <param name="message">The error message to report.</param>
        </member>
        <member name="M:VL.Core.SerializationContext.GetTagName(System.Type)">
            <summary>
            Returns the name of the type without any generic type parameter suffixes and replaces [] with Array.
            </summary>
        </member>
        <member name="T:VL.Core.SerializationException">
            <summary>
            Represents errors that occur during serialization.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationException.#ctor(System.String)">
            <summary>
            Creates a new instances of the <see cref="T:VL.Core.SerializationException"/> class with the specified error message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="T:VL.Core.Serialization">
            <summary>
            Serialization related extension methods and constants.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.ReflectionNamespace">
            <summary>
            The reflection namespace.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.TypeAttributeName">
            <summary>
            The name of the type attribute.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.VersionAttributeName">
            <summary>
            The name of the version attribute.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializer``2(VL.Core.IVLFactory,``1)">
            <summary>
            Registers a VL serializer to the factory. 
            In case the type for which the serializer gets registered is generic a dummy type instantiation paired with a dummy
            serializer instantiation containing a public default constructor has to be registered. For example a serializer implementation
            of type FooSerializer&lt;T&gt; for the generic type Foo&lt;T&gt; has to be registered for the dummy instantiaton Foo&lt;object&gt;.
            </summary>
            <typeparam name="TForType">The type for which to register a serializer.</typeparam>
            <typeparam name="TSerializer">The type of the serializer implementation.</typeparam>
            <param name="factory">The factory in which the serializer gets registered.</param>
            <param name="serializer">The serializer to register.</param>
            <returns>The factory with the registered serializer.</returns>
        </member>
        <member name="M:VL.Core.Serialization.CanSerialize(VL.Core.IVLFactory,System.Type)">
            <summary>
            Whether or not an instance of the given type can be serialized.
            </summary>
            <param name="factory">The factory containing the serializer registrations.</param>
            <param name="forType">The type of the instance to serialize.</param>
            <returns>True if an instance of the given type can be serialized.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.SerializationContext,System.String,``0,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </typeparam>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize(VL.Core.SerializationContext,System.String,System.Object,System.Type,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="staticType">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.SerializationContext,System.Object,System.String)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize(VL.Core.SerializationContext,System.Object,System.String,System.Type)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <param name="staticType">The statically known type of the value to deserialize.</param>
            <returns>The deserialized value or the default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.CollectionSerializer`2">
            <summary>
            The abstract base class to use when writing a VL serializer for a collection type.
            </summary>
            <typeparam name="TElement">The element type of the collection.</typeparam>
            <typeparam name="TCollection">The type of the collection.</typeparam>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.IVLFactory,``0,System.Boolean)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case serialization fails.</remarks>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="factory">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <param name="includeDefaults">Whether or not default values should be serialized.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.IVLFactory,``0,System.Boolean,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="factory">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.IVLFactory,System.Xml.Linq.XElement)">
            <summary>
            Deserializes the given content.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case deserialization fails.</remarks>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="factory">The factory to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.IVLFactory,System.Xml.Linq.XElement,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Deserializes the given content.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="factory">The factory to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="throwOnError">Whether or not deserialization errors should lead to an exception.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializers(VL.Core.IVLFactory)">
            <summary>
            Registers all the default serializers in the factory.
            </summary>
            <param name="factory">The factory to register in.</param>
        </member>
        <member name="M:VL.Core.Serialization.GetSerializer(VL.Core.IVLFactory,System.Type)">
            <summary>
            Gets a serializer for the given type.
            </summary>
            <param name="factory">The factory to fetch the serializer from.</param>
            <param name="forType">The type for which a serializer has to be fetched.</param>
            <returns>The serializer or null in case no serializer is registered for that type.</returns>
        </member>
        <member name="T:VL.Core.Serialization.Serializer">
            <summary>
            The non-generic serializer class.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Serialize(VL.Core.SerializationContext,System.Object)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The serialized value as <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Deserialize(VL.Core.SerializationContext,System.Object,System.Type)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="type">The type of the deserialized value.</param>
            <returns>The deserialized value or the default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.UngenericDelegatingSerializer`1">
            <summary>
            Bridge to user implemented generic serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="M:VL.Core.SingleAppInstanceUtils.GetOrAddAppMutex(System.String,System.Boolean@,System.Boolean)">
            <summary>
            Tries to create a mutex with given name. Also sets the static OtherInstanceIsRunning property.
            </summary>
            <param name="mutexName">Name of the mutex.</param>
            <param name="isNew">True if the mutex was created, false if another instance exists already</param>
            <param name="addGlobalPrefix">If set to <c>true</c> the "Global\" prefis is added.</param>
            <returns>
            The new or existing mutex.
            </returns>
        </member>
        <member name="T:VL.Core.IHasMemory`1">
            <summary>
            Allows to get access to the backing <see cref="T:System.ReadOnlyMemory`1"/> or <see cref="T:System.Memory`1"/> of the implementing class.
            </summary>
            <remarks>
            Currently implemented by <see cref="T:VL.Lib.Collections.Spread`1" /> and <see cref="T:VL.Lib.Collections.SpreadBuilder`1"/>
            </remarks>
            <typeparam name="T">The elment type.</typeparam>
        </member>
        <member name="M:VL.Core.IHasMemory`1.TryGetMemory(System.Memory{`0}@)">
            <summary>
            Tries to get access on the backing continuous <see cref="T:System.Memory`1"/>.
            </summary>
            <param name="memory">The continuous block of <see cref="T:System.Memory`1"/>.</param>
            <returns>Whether or not access to the <see cref="T:System.Memory`1"/> is granted.</returns>
        </member>
        <member name="M:VL.Core.IHasMemory`1.TryGetMemory(System.ReadOnlyMemory{`0}@)">
            <summary>
            Tries to get access on the backing continuous <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <param name="memory">The continuous block of <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>Whether or not access to the <see cref="T:System.ReadOnlyMemory`1"/> is granted.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Empty``1">
            <summary>
            Returns empty memory.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <returns>The empty memory.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.HasData``1(VL.Core.IHasMemory{``0})">
            <summary>
            Wether or not not-empty <see cref="T:System.ReadOnlyMemory`1"/> is available.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>True if not-empty <see cref="T:System.ReadOnlyMemory`1"/> is available.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Length``1(VL.Core.IHasMemory{``0})">
            <summary>
            The length in elements of the memory block.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The length of the memory block.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Size``1(VL.Core.IHasMemory{``0})">
            <summary>
            The size in bytes of the memory block.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The size in bytes of the memory block.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.ElementSize``1(VL.Core.IHasMemory{``0})">
            <summary>
            Returns the size in bytes of one element of the memory.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The size of one element in bytes.</returns>
        </member>
        <member name="P:VL.Core.VersionUtils.IsPreview">
            <summary>
            Whether or not this is a preview build.
            </summary>
        </member>
        <member name="P:VL.Core.VersionUtils.FullVersionString">
            <summary>
            The full version string. e.g. "2019.1.0" or "2019.1.0-0063-g2b0be431ff" for preview
            </summary>
        </member>
        <member name="M:VL.Core.VersionUtils.InformationalVersionToUserVersion(System.String)">
            <summary>
            Parses an informational preview version to user version. e.g. "2019.1.0-63+g2b0be431ff" to "2019.1.0-0063-g2b0be431ff".
            Release version will be returned without change, e.g. "2019.1.0"
            </summary>
        </member>
        <member name="M:VL.Core.VersionUtils.ParseLanguageVersion(System.String)">
            <summary>
            Parses the LanguageVersion attribute of documents to a version. 
            Handles strings like "2019.1.0" or "2019.1.0-0063-g2b0be431ff" or "2019.1.0-roslyn.763-g631ba19afb" or "2019.1.0-763.roslyn-g631ba19afb"
            </summary>
        </member>
        <member name="T:VL.Core.MapMode">
            <summary>
            vvvv like modi for the Map function
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Float">
            <summary>
            Maps the value continously
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Clamp">
            <summary>
            Maps the value, but clamps it at the min/max borders of the output range
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Wrap">
            <summary>
            Maps the value, but repeats it into the min/max range, like a modulo function
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Mirror">
            <summary>
            Maps the value, but mirrors it into the min/max range, always against either start or end, whatever is closer
            </summary>
        </member>
        <member name="T:VL.Core.VLMath">
            <summary>
            The vvvv c# math routines library
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.Pi">
            <summary>
            Pi, as you know it
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.TwoPi">
            <summary>
            Pi * 2
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.PiRez">
            <summary>
            1 / Pi, multiply by this if you have to divide by Pi
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.TwoPiRez">
            <summary>
            2 / Pi, multiply by this if you have to divide by 2*Pi
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.CycToRad">
            <summary>
            Conversion factor from cycles to radians, (2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.RadToCyc">
            <summary>
            Conversion factor from radians to cycles, 1/(2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.DegToRad">
            <summary>
            Conversion factor from degree to radians, (2 * Pi)/360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.RadToDeg">
            <summary>
            Conversion factor from radians to degree, 360/(2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.DegToCyc">
            <summary>
            Conversion factor from degree to radians, 1/360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.CycToDeg">
            <summary>
            Conversion factor from radians to degree, 360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.IdentityMatrix">
            <summary>
            Identity matrix 
            1000 
            0100
            0010
            0001
            </summary>
        </member>
        <member name="M:VL.Core.VLMath.Factorial(System.Int32)">
            <summary>
            Factorial function, DON'T FEED ME WITH LARGE NUMBERS !!! (n>10 can be huge)
            </summary>
            <param name="n"></param>
            <returns>The product n * n-1 * n-2 * n-3 * .. * 3 * 2 * 1</returns>
        </member>
        <member name="M:VL.Core.VLMath.Binomial(System.Int32,System.Int32)">
            <summary>
            Binomial function
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns>The number of k-tuples of n items</returns>
        </member>
        <member name="M:VL.Core.VLMath.Pow(System.Single,System.Int32)">
            <summary>
            Raises x to the power of y.
            </summary>
            <param name="x">The base.</param>
            <param name="y">The exponent.</param>
            <returns>Returns x raised to the power of y.</returns>
            <remarks>This method should be considerably faster than Math.Pow for small y.</remarks>
        </member>
        <member name="M:VL.Core.VLMath.SolveQuadratic(System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Solves a quadratic equation a*x^2 + b*x + c for x
            </summary>
            <param name="a">Coefficient of x^2</param>
            <param name="b">Coefficient of x</param>
            <param name="c">Constant</param>
            <param name="x1">First solution</param>
            <param name="x2">Second solution</param>
            <returns>Number of solution, 0, 1, 2 or int.MaxValue</returns>
        </member>
        <member name="M:VL.Core.VLMath.Min(System.Single,System.Single)">
            <summary>
            Min function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Smaller value of the two input parameters</returns>
        </member>
        <member name="M:VL.Core.VLMath.Max(System.Single,System.Single)">
            <summary>
            Max function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Greater value of the two input parameters</returns>
        </member>
        <member name="M:VL.Core.VLMath.Zmod(System.Int32,System.Int32)">
            <summary>
            Modulo function with the property, that the remainder of a division z / d
            and z &lt; 0 is positive. For example: zmod(-2, 30) = 28.
            </summary>
            <param name="z"></param>
            <param name="d"></param>
            <returns>Remainder of division z / d.</returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a floating point value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Clamp function, clamps a floating point value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamp function, clamps an integer value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Int64,System.Int64,System.Int64)">
            <summary>
            Clamp function, clamps a long value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector2,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector3,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector4,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(System.Single)">
            <summary>
            Abs function for values, just for completeness
            </summary>
            <param name="a"></param>
            <returns>New value with the absolut value of a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(Stride.Core.Mathematics.Vector2)">
            <summary>
            Abs function for 2d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(Stride.Core.Mathematics.Vector3)">
            <summary>
            Abs function for 3d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(Stride.Core.Mathematics.Vector4)">
            <summary>
            Abs function for 4d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Ratio(System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            This Method can be seen as an inverse of Lerp (in Mode Float). Additionally it provides the infamous Mapping Modes, author: velcrome
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="start">Minimum of input value range</param>
            <param name="end">Maximum of input value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input value mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(System.Single,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for values
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input value mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector2,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector3,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector4,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linear interpolation (blending) between two values
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Linear interpolation between a and b if x in the range ]0..1[ or a if x = 0 or b if x = 1</returns>
        </member>
        <member name="F:VL.Core.VLObject.WithMethodName">
            <summary>
            The name of the auto generated With method used to update the fields.
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameTimeMessage.Time">
            <summary>
            The frame time since application start
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameTimeMessage.LastInterval">
            <summary>
            The time interval between the last frame and the current frame.
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameFinishedMessage.Time">
            <summary>
            The frame time since application start
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameFinishedMessage.FrameDuration">
            <summary>
            The elapsed time since the current frame has started
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameFinishedMessage.LastInterval">
            <summary>
            The time interval between the last frame and the current frame.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.IFrameClock.TimeDifference">
            <summary>
            Gets the time difference between the frame time of the last frame to the current frame time.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.IFrameClock.GetTicks">
            <summary>
            Gets an observable that sends an event before each frame.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.IFrameClock.GetFrameFinished">
            <summary>
            Gets an observable that sends an event directly after the Update call of each frame.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.FrameClock">
            <summary>
            The clock used to determine the time when the current frame of the vl mainloop started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentFrameTime">
            <summary>
            The time when the current frame started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.RealTimeClock">
            <summary>
            The clock used to determine the current time, returns a new time value for each call
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentTime">
            <summary>
            Checks time now
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameClock.MinTimeDifferenceInSeconds">
            <summary>
            One micro second. Minimal time difference of frame clock, avoids DivideByZero exceptions in animation nodes.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.FrameClock.SetFrameTime(VL.Lib.Animation.Time)">
            <summary>
            Used on start of the frame, sets the frame time and triggers the before frame tick event.
            </summary>
            <param name="frameTime">The absolute time since start. Global parameter used by the animation nodes</param>
        </member>
        <member name="M:VL.Lib.Animation.FrameClock.NotifyFrameFinished">
            <summary>
            Used immediately after the frame work is done, sets the frame duration time and triggers the frame finished event.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.FrameClock.Update">
            <summary>
            Calls SetFrameTime with the time of the current real time clock.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.DesiredTimeDifference">
            <summary>
            Desired interval time in seconds, also used to initialize the time difference on first frame and restart.
            Defalt is 1/60.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.IsIncremental">
            <summary>
            Enables fixed increment time mode.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.TimeIncrement">
            <summary>
            Desired increment time in seconds, used if <see cref="P:VL.Lib.Animation.FrameClock.IsIncremental"/> is set to true;
            Defalt is 1/60.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.WaitAccuracy">
            <summary>
            Estimated precision of the accuracy of Sleep(1) on the current machine in seconds.
            Default is 0.002s (2ms). Usually between 1ms and 16ms. Higher values make the timer more precise but uses more CPU power.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.Elapsed">
            <summary>
            The elapsed time since start as TimeSpan, setting the property will call SetFrameTime and update the clock variables.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTime(System.DateTime)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTimeUTC(System.DateTimeOffset)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareAdded">
            <summary>
            Checks for device additions, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareRemoved">
            <summary>
            Checks for device removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareChanged">
            <summary>
            Checks for device additions and removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="F:VL.Lib.HardwareChangedEvents.WaitForInstallationTimeoutInMilliseconds">
            <summary>
            The wait for installation timeout in milliseconds, defaults to 1 minute
            </summary>
        </member>
        <member name="T:VL.Lib.GUID_DEVCLASS">
            <summary>
             Defines GUIDs for device classes used in Plug &amp; Play.
            </summary>
        </member>
        <member name="T:VL.Lib.Reactive.HoldLatestCopy`2">
            <summary>
            Holds on to a copy of the latest received data. Whenever data gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ArrayBuilder`1">
            <summary>
            Allows to build up arrays in an efficient way.
            </summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in the builder.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the builder.</returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.ElementAtOrDefault(System.Int32)">
            <summary>
            Gets the element at the specified index in the builder or the default value if the index is out of range.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the builder or the default value if the index is out of range.</returns>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Count">
            <summary>
            The amount of items currently stored in the builder.
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Capacity">
            <summary>
            The capacity of the builder.
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.IsDefault">
            <summary>
            Whether or not this is the default instance - the internall array is null.
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Buffer">
            <summary>
            Gives access to the internally used array. The length of the returned array might be greater then the item count of the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsSpan">
            <summary>
            Exposes the content of the builder as a <see cref="T:System.Span`1"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsMemory">
            <summary>
            Exposes the content of the builder as <see cref="T:System.Memory`1"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsArraySegment">
            <summary>
            Exposes the content of the builder as <see cref="T:System.ArraySegment`1"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsArray">
            <summary>
            Resizes the internal array to the count of the builder and returns it.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsArray(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns the upstream sequence as an array. This can be done efficiently without copying for immutable collections based on arrays like
            <see cref="T:VL.Lib.Collections.Spread`1"/> or <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>. For other collection types the content will be copied into
            the internal array and returned.
            </summary>
            <param name="items">The upstream sequence.</param>
            <returns>The array from the upstream immutable array based collection or the internal array containing the content.</returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Add(`0)">
            <summary>
            Add an item to the builder.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.UncheckedAdd(`0)">
            <summary>
            Add an item to the builder without checking whether the capacity is large enough. Use only if capacity is large enough.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a range of items to the builder. The sequence will be checked for well known collection types in order to do the copying efficiently.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(System.ReadOnlySpan{`0}@)">
            <summary>
            Adds the items to the builder.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(`0[])">
            <summary>
            Adds the items to the builder.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds the items to the builder.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Clear">
            <summary>
            Clears the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the current contents to the specified array.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="index">The starting index of the target array.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Remove(`0)">
            <summary>
            Removes the specified element.
            </summary>
            <param name="element">The element.</param>
            <returns>A value indicating whether the specified element was found and removed from the collection.</returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Reverse">
            <summary>
            Reverses the order of elements in the collection.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort">
            <summary>
            Sorts the array.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort(System.Comparison{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="comparer">The comparer to use in sorting.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="index">The index of the first element to consider in the sort.</param>
            <param name="count">The number of elements to include in the sort.</param>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Value">
            <summary>
            Gets the current enum value as string
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Tag">
            <summary>
            Gets the associated tag if the enum definition has registered one.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnum.CreateValue(System.String)">
            <summary>
            Creates a new enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Default">
            <summary>
            Creates the default enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Definition">
            <summary>
            Gets the definition of this enum with all entries
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.OnChange">
            <summary>
            Fires when the definition changes, i.e. entries get added or removed
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.Entries">
            <summary>
            Gets the current list of valid entries
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnumDefinition.IsValid(System.String)">
            <summary>
            Returns true if the string is a valid entry of this enum type
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.EmptyEnumFallbackMessage">
            <summary>
            Gets the empty enum fallback string for cases when no entries are in the enum definition.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.IsValid(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Returns true if the value is in the current entry list of the definition.
            </summary>
            <returns>
              <c>true</c> if the specified input is valid, not null and its value is not a null or empty string; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.SelectedIndex(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Gets the index of the selected item in the entries list of its definition.
            Can return -1 if the string is not in the current list of entries.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.CreateValue``1(``0,System.String)">
            <summary>
            Creates a new enum value of given type
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.TrySelectIndex``1(``0,System.Int32,System.Boolean@,``0@)">
            <summary>
            Sets the selected item to the value at the index in the entries list of its definition.
            If the index is out of range, returns false and the input value.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumBase`2">
            <summary>
            Base class for easy dynamic enum implementaion. Use like this:
            MyEnumClass : DynamicEnumBase&lt;MyEnumClass&gt; and override 
            IDynamicEnumDefinition Definition { get; } and define a default value:
            public static MidiInputDevice Default => new MyEnumClass("Default Entry");
            <typeparam name="TSubclass">The type of the actual dynamic enum class.</typeparam>
            <typeparam name="TDefinitionClass">The type of the enum definition.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnum" />
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumBase`2.CreateDefaultBase(System.String)">
            <summary>
            Can be used in subclass to create the default, selects the first entry.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.AnyDynamicEnumDefinitionChanged">
            <summary>
            Static class used to inform the compiler that a dynamic enum definition has changed
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumDefinitionBase`1">
            <summary>
            Base class for dynamic enum definitions.
            Takes care of the singleton pattern and the update of the entries. Use like this:
            MyEnumDefinitionClass : DynamicEnumBase&lt;MyEnumDefinitionClass&gt; and override the two abstract methods.
            <typeparam name="TDefinitionSubclass">The type of the actual definition class.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnumDefinition" />
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ISpread">
            <summary>
            Non-generic spread interface.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.AsMemory">
            <summary>
            Creates a new read-only memory region over this spread.
            </summary>
            <returns>The read-only memory representation of this spread.</returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.AsSpan">
            <summary>
            Creates a new read-only span region over this spread.
            </summary>
            <returns>The read-only span representation of this spread.</returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.ToBuilder">
            <summary>
            Creates a spread builder with the same contents as this spread that can be efficiently modified across multiple operations
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.IsEmpty">
            <summary>
            Whether or not the spread is empty
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Count">
            <summary>
            Returns the number of slices in the spread
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Item(System.Int32)">
            <summary>
            Returns the item at the specified index. Can throw ArgumentOutOfRangeException exception
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns the index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:VL.Lib.Collections.Spread">
            <summary>
            Contains all those methods which are used in C# and VL.
            Methods which are only used in VL reside in SpreadNodes.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.SizeInBytes``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            The size in bytes = element type size * count.
            Returns IntPtr * count for reference types.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.GetInternalArray``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            Gets the internal data array of the spread, use at your own risk, i.e. never modify it.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.AsSpreadUnsafe``1(``0[])">
            <summary>
            Interprets the array as a spread. The array must not mutate after this call or the immutability of the spread is violated.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ISpreadBuilder">
            <summary>
            Non-generic view on spread builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ISpreadBuilder.ToSpread">
            <summary>
            Returns an immutable spread of the current contents of the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the item at specified index
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at specified index
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.CopyTo(`0[],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies 'Count' elements from 'Start Index' to an Array at the 'Array Index' position
            </summary>
            <param name="array"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="arrayIndex"></param>
            <param name="reverseOrder"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            Removes all the elements that match the conditions defined by the specified predicate.
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort">
            <summary>
            Sorts the elements in the entire spread builder using the default comparer
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort(System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the elements in the entire spread builder using the specified comparer function
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.HoldLatestCopy">
            <summary>
            Holds on to a copy of the latest received image. Whenever an image gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageExtensions.Default">
            <summary>
            A white one by one pixel RGBA image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(``0[],System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the array accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided array is only valid in the current call stack.</param>
            <returns>An image which uses the array as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(VL.Lib.Collections.Spread{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the spread accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>An image which uses the spread as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Tries to fetch the backing memory of the given <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and makes its data accessible as an image. No data gets copied. 
            In case the data can't be accessed as a <see cref="T:System.ReadOnlyMemory`1"/> the default image will be returned.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image using the given data as its backing store or the default image if backing memory couldn't be fetched.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(System.ReadOnlyMemory{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the memory accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image which uses the given memory as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.Drawing.Bitmap,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Makes the bitmap accessible as an image. No data gets copied.
            </summary>
            <param name="bitmap">The bitmap to wrap.</param>
            <param name="takeOwnership">Whether or not the wrapper should take ownership of the bitmap. So in case it gets disposed the bitmap will also get disposed.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the bitmap gets modified later.</param>
            <param name="canWrite">Whether or not one can write into the bitmap.</param>
            <returns>The image wrapping the bitmap.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.IntPtr,System.Int32,System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the pointer accessible as an image. No data gets copied. The returned image is volatile and should get disposed of.
            Once disposed further access to <see cref="M:VL.Lib.Basics.Imaging.IImage.GetData"/> will return the image data from the default image.
            </summary>
            <param name="pointer">The pointer to the data of the image.</param>
            <param name="size">The size in bytes of the image data.</param>
            <param name="width">The width in pixel.</param>
            <param name="height">The height in pixel.</param>
            <param name="format">The pixel format.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>A volatile image using the pointer as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.Clone(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CloneEmpty(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Creates an empty clone of the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>An image of the same size and format but with all pixels set to zero.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.AsNewImage(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Creates a new image instance without copying any data. Useful to propagate changed information.
            </summary>
            <param name="image">The image to "re-sell" as a new image.</param>
            <returns>A new image instance reusing all the data of the input image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.HasSameInfo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Whether or not the image info is the same.
            </summary>
            <param name="image">The image.</param>
            <param name="other">The other image to compare the info with.</param>
            <returns>True if the image info is the same</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.IImage@)">
            <summary>
            Copies the source image to the destination location. If the destination is not yet assigned or if the image
            information doesn't fit a new image will be created and assigned to the destination.
            </summary>
            <param name="src">The image to copy from.</param>
            <param name="dst">The destination location to copy the image to.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Copies the source image to the destination image. The source and destination images must have the same format.
            </summary>
            <param name="src">The image to copy from.</param>
            <param name="dst">The image to copy to.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToStream(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Makes the image accessible as a stream.
            </summary>
            <param name="image">The image to wrap.</param>
            <returns>A stream which will read from the image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImageData,VL.Lib.Basics.Imaging.IImageData)">
            <summary>
            Copies the pixels of the image to the destination.
            </summary>
            <param name="srcData">The source image data.</param>
            <param name="dstData">The destination image data.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.FromImage(VL.Lib.Basics.Imaging.IImage,System.Boolean)">
            <summary>
            Makes the <see cref="T:VL.Lib.Basics.Imaging.IImage"/> accessible as a <see cref="T:System.Drawing.Bitmap"/> by either copying the pixels or wrapping them.
            </summary>
            <param name="image">The image to either copy the pixels from or wrap in a <see cref="T:System.Drawing.Bitmap"/>.</param>
            <param name="copy">Whether or not to copy the pixels.</param>
            <returns>The <see cref="T:System.Drawing.Bitmap"/> containing either the copied pixels or pointing to the upstream image data.</returns>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ImageInfo">
            <summary>
            A structure containing size information of an image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Width">
            <summary>
            The width of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Height">
            <summary>
            The height of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Format">
            <summary>
            The pixel format of the image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.OriginalFormat">
            <summary>
            The original pixel format as defined by the library the image was loaded from.
            Can be used in case the <see cref="F:VL.Lib.Basics.Imaging.ImageInfo.Format"/> property is set to <see cref="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.#ctor(System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Creates a new instance of the image info structure.
            </summary>
            <param name="width">The width of the image in pixel.</param>
            <param name="height">The height of the image in pixel.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The pixel format like it was provided by the original library.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.Split(System.Int32@,System.Int32@,VL.Lib.Basics.Imaging.PixelFormat@,System.String@)">
            <summary>
            Splits the image info up into its components.
            </summary>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The original format string (if any) of the image.</param>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.PixelSize">
            <summary>
            The size of a pixel in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ImageSize">
            <summary>
            The size of the image in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ScanSize">
            <summary>
            The size of one scan line (row of pixels) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ArrayImage`1">
            <summary>
            Image implementation using an array as backing store.
            </summary>
            <typeparam name="T">The elment type of one channel.</typeparam>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.BitmapImage">
            <summary>
            Image implementation using a <see cref="T:System.Drawing.Bitmap"/> as backing store. Must be disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IntPtrImage">
            <summary>
            Image implementation using unmanaged memory as backing store. Must be disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImage">
            <summary>
            Gives read-only access to images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.Info">
            <summary>
            A structure containing size and format information of the image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.IImage.GetData">
            <summary>
            Gives access to image's data. Must be disposed after being used.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.IsVolatile">
            <summary>
            A volatile image is only valid in the current call stack.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImageData">
            <summary>
            Used for reading images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Bytes">
            <summary>
            Gets the pixel data.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.ScanSize">
            <summary>
            The scan size (one row of pixels including padding) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.PixelFormat">
            <summary>
            An enumeration of commonly used pixel formats.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown">
            <summary>
            Unkown pixel format.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8">
            <summary>
            A single-component, 8-bit unsigned-normalized-integer format that supports 8 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R16">
            <summary>
            A single-component, 16-bit unsigned-normalized-integer format that supports 16 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32F">
            <summary>
            A single-component, 32-bit floating-point format that supports 32 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8">
            <summary>
            24-bit RGB pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8">
            <summary>
            24-bit BGR pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8X8">
            <summary>
            32-bit RGBx pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8A8">
            <summary>
            32-bit RGBA pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8X8">
            <summary>
            32-bit BGRx pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8A8">
            <summary>
            32-bit BGRA pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32G32B32A32F">
            <summary>
            128-bit RGBA floating point pixel format using 32 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32G32F">
            <summary>
            A two-component, 64-bit floating-point format using 32 bits for each channel.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.UsingAsync``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetch a resource, use it, let it get disposed of when the Task is done.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.ToObservable``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetches a resource and fires a result when the worker task is done. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool. Check the Cancelation token in your worker to stop work if cancelation was requested.
            </summary>        
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceProvider`1">
            <summary>
            Provides an IResourceHandle, which provides access to a Disposable resource.
            Consumers need to dispose these Handles.
            Implementations provide mechanisms for distributing and sharing Disposable resources.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceHandle`1">
            <summary>
            Is returned by IResourceProvider.GetHandle().
            Provides access to a Disposable Resource.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IConnectableResourceProvider`1">
            <summary>
            A connectable resource provider only works after calling Connect. 
            Disconnect via the disposable returned by Connect(). Only then the upstream handle gets disposed of.
            Used to share Resources more efficiently while connected.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledInternal``2(System.Collections.Generic.Dictionary{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},``0,System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="pool">The pool to use</param>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``2(VL.Core.NodeContext,``0,System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">The Node Context gets fed by VL. Used to figure out which app this node is in.</param>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``2(VL.Core.NodeContext,``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">The Node Context gets fed by VL. Used to figure out which app this node is in.</param>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``1(VL.Core.NodeContext,System.Func{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">The Node Context gets fed by VL. Used to figure out which app this node is in.</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``1(VL.Core.NodeContext,System.Func{``0},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">The Node Context gets fed by VL. Used to figure out which app this node is in.</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledSystemWide``2(``0,System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledSystemWide``2(``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0},System.Action{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Return``1(``0)">
            <summary>
            Will always provide same single resource. It exists already. 
            So its not the responsibility of Return() to dispose it.
            
            Could also imagine a ReturnLazy that takes a Func&lt;TResource&gt;, 
            but as it is used mostly inside the monade it is already lazy to GetHandle() from downstream
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}})">
            <summary>
            SelectMany
            Create a ResourceProvider per source resource. Creating any provider will work.
            Takes into account that the resulting resources may depend on the source resources.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will not get managed as it may exist already. (Select(form => form.Controls[0]) should not dispose the control)
            If you create a new resource that you want to get managed use BindNew for this.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a new resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will get managed.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Do``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Applies an action on a resource and outputs the same resource again.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Where``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Boolean})">
            <summary>
            Just doesn't let you access a resource that doesn't match your needs. Gives you default instead.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.PublishPooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            Manages a pool of handles from the upstream provider.
            On GetHandle, this will return a Handle containing a resource that is not currently in use.
            Manages a pool of upstream handles. When a downstream handle gets disposed, it's inner upstream Handle will be put back into the pool.
            
            Will dispose every upstream handle still in the pool on disconnect.
            Former disposable provider Pool
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``1(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.Int32)">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After delayDisposalInMilliseconds, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``2(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After disposalTriggerSource fired, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Serialize``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Handles get handed out in a serial fashion. Only one handle is in circulation at a given point in time.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32)">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify how long the resource stays valid after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify how long the resource stays valid. 
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify how long the resources in the pool stay valid after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Cata
            Empty using statement
            Only use for sideeffects of the upstream ResourceProvider Monad
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Cata
            Runs the action on the resource
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Cata
            Runs the extractor on the resource and returns the output.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``3(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},System.Func{``0,``1,``2})">
            <summary>
            Return a resource using two source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Return a resource using three source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Return a resource using four source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Create a new resource using three source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Create a new resource using four source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Finally``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Act on the resource right before it gets disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Handle`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Provider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.ConnectableProvider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable returned by Connect().
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.GetLatestResourceForTemporaryUse`1">
            <summary>
            Takes a resourceprovider and outputs its resource
            Makes sure to call GetHandle before releasing the old handle.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsFile">
            <summary>
            Returns whether the path is a file
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsDirectory">
            <summary>
            Returns whether the path is a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsRooted">
            <summary>
            Whether the path string contains a root.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Root">
            <summary>
            Returns the root path (if any).
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Size">
            <summary>
            Returns the size of a file or all the files in a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Exists">
            <summary>
            Returns whether file or folder exists
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.Refresh">
            <summary>
            Updates all properties of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.IO.Path.Parent">
            <summary>
            For a directory returns its parent directory. For a file returns the directory the file is in
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDescendants(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files and folders contained withinin a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDirectories(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all folders contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetFiles(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.Filename(System.String@,System.String@,System.String@)">
            <summary>
            Returns the directory path and the name and extension of a file
            </summary>
            <param name="directory"></param>
            <param name="filename"></param>
            <param name="extension"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.GetAttributes(System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Returns readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.SetAttributes(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.Modified(System.DateTime@,System.DateTime@,System.DateTime@)">
            <summary>
            Returns creation date, last write and last access dates of a file or folder
            </summary>
            <param name="creationTime"></param>
            <param name="lastWriteTime"></param>
            <param name="lastAccessTime"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeRelative(VL.Lib.IO.Path)">
            <summary>
            Returns this absolute path as a relative path to the given base path.
            In case the base path has a different root than this path or this path is relative already 
            the same path will be returned.
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeAbsolute(VL.Lib.IO.Path)">
            <summary>
            Returns this relative path as an absolute path to the given base path.
            In case this path is absolute already the same path will be returned.
            </summary>
        </member>
        <member name="T:KPreisser.AsyncReaderWriterLockSlim">
            <summary>
            An alternative to <see cref="T:System.Threading.ReaderWriterLockSlim"/> which can be used in async methods.
            </summary>
            <remarks>
            This implementation has the following differences to <see cref="T:System.Threading.ReaderWriterLockSlim"/>:
            - The lock is not thread-affine, which means one thread can enter the lock,
              and a different thread can release it. This allows you to use the lock in an async
              method with a await call between entering and releasing the lock.
            - Additionally to synchronous methods like <see cref="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLock(System.Threading.CancellationToken)"/>,
              it has asynchronous methods like <see cref="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLockAsync(System.Threading.CancellationToken)"/> which
              can be called in async methods, so that the current thread is not blocked while waiting
              for the lock.
            - Because this class doesn't have thread affinity, recursive locks are not supported (which
              also means they cannot be detected). In order for the lock to work correctly, you must not
              recursively enter the lock from the same execution flow.
            - The lock does not support upgradeable read mode locks that can be upgraded to a write mode
              lock, due to the complexity this would add.
              
            The lock can have different modes:
            - Read mode: One or more 'read mode' locks can be active at a time while no 'write mode' lock
              is active.
            - Write Mode: One 'write mode' lock can be active at a time while no other
              'write mode' locks and no other 'read mode' locks are active.
            
            When a task or thread ("execution flow") tries to enter a 'write mode' lock while at least one
            'read mode' lock is active, it is blocked until the last 'read mode' lock is released.
            
            When a task or thread tries to enter a 'read mode' lock while a 'write mode' lock is active,
            it is blocked until the 'write mode' lock is released.
            
            If, while other 'read mode' locks are active and the current task or thread waits to enter
            the 'write mode' lock, another task or thread tries
            to enter a 'read mode' lock, it is blocked until
            the current task or thread released the 'write mode' lock (or canceled the wait operation), 
            which means writers are favored in this case.
            
            Also, when a 'write mode' lock is released while there are one or more execution flows
            trying to enter a *write mode* lock and also one or more execution flows trying to enter a
            'read mode' lock, writers are favored.
            
            The lock internally uses <see cref="T:System.Threading.SemaphoreSlim"/>s to implement wait functionality.
            </remarks>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.writeLockSemaphore">
            <summary>
            A <see cref="T:System.Threading.SemaphoreSlim"/> which is used to manage the write lock.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.readLockReleaseSemaphore">
            <summary>
            A <see cref="T:System.Threading.SemaphoreSlim"/> which a write lock uses to wait until the last
            active read lock is released.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.currentWriteLockState">
            <summary>
            If not <c>null</c>, contains the <see cref="T:KPreisser.AsyncReaderWriterLockSlim.WriteLockState"/> that represents the
            state of the current write lock. This field may be set even if
            <see cref="F:KPreisser.AsyncReaderWriterLockSlim.currentReadLockCount"/> is not yet 0, in which case the task or thread
            trying to get the write lock needs to wait until the existing read locks are left.
            However, while this field is set, no new read locks can be acquired.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.currentReadLockCount">
            <summary>
            The number of currently held read locks.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.currentWaitingWriteLockCount">
            <summary>
            The number of tasks or threads that intend to wait on the <see cref="F:KPreisser.AsyncReaderWriterLockSlim.writeLockSemaphore"/>.
            This is used to check if the <see cref="F:KPreisser.AsyncReaderWriterLockSlim.currentWriteLockState"/> should already be
            cleaned-up when the write lock is released.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> class.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/>.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLock(System.Threading.CancellationToken)">
            <summary>
            Enters the lock in read mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in read mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete when the lock has been entered.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterReadLock(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns><c>true</c> if the lock has been entered, otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterReadLockAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a result of <c>true</c> if the lock has been entered,
            otherwise with a result of <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterWriteLock(System.Threading.CancellationToken)">
            <summary>
            Enters the lock in write mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterWriteLockAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in write mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete when the lock has been entered.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterWriteLock(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns><c>true</c> if the lock has been entered, otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterWriteLockAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a result of <c>true</c> if the lock has been entered,
            otherwise with a result of <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.DowngradeWriteLockToReadLock">
            <summary>
            Downgrades the lock from write mode to read mode.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.ExitReadLock">
            <summary>
            Exits read mode.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.ExitWriteLock">
            <summary>
            Exits write mode.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> and
            optionally releases the managed resources.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.StateIsActive">
            <summary>
            Gets or sets a value that indicates if the state is active. Only when <c>true</c>, the
            <see cref="F:KPreisser.AsyncReaderWriterLockSlim.readLockReleaseSemaphore"/> will be released once the last read lock exits.
            </summary>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.StateIsReleased">
            <summary>
            Gets or sets a value that indicates if the write lock associated with this
            <see cref="T:KPreisser.AsyncReaderWriterLockSlim.WriteLockState"/> has already been released. This is also used
            to indicate if the the task or thread that waits on the
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> semaphore and then decrements
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksCount"/> to zero (0) must dispose the
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> semaphore.
            </summary>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore">
            <summary>
            Gets or sets a <see cref="T:System.Threading.SemaphoreSlim"/> on which new read locks need
            to wait until the existing write lock is released. The <see cref="T:System.Threading.SemaphoreSlim"/>
            will be created only if there is at least on additional task or thread that wants
            to enter a read lock.
            </summary>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksCount">
            <summary>
            Gets or sets a value that indicates the number of tasks or threads which intend
            to wait on the <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> semaphore. This
            is used to determine which task or thread is responsible to dispose the 
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> if
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.StateIsReleased"/> is <c>true</c>.
            </summary>
        </member>
        <member name="T:KPreisser.AsyncReaderWriterLockSlimExtension">
            <summary>
            Contains extension methods for <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/>.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetReadLock(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Enters the lock in read mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetReadLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in read mode and returns a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that
            will release the lock when disposed.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> when the lock has been entered,
            which will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetReadLock(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed if the lock
            could be entered, or <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetReadLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock
            when disposed if the lock could be entered, or with <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetWriteLock(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Enters the lock in write mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetWriteLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in write mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> when the lock has been entered,
            which will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetWriteLock(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed if the lock
            could be entered, or <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetWriteLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock
            when disposed if the lock could be entered, or with <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.DowngradeWriteLockToReadLock(KPreisser.AsyncReaderWriterLockSlim,KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock)">
            <summary>
            Downgrades the lock from write mode to read mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="readLock">The <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> which should be downgraded.</param>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock">
            <summary>
            
            </summary>
        </member>
        <member name="M:KPreisser.TimeUtils.GetTimestampTicks(System.Boolean)">
            <summary>
            Gets a timestamp in DateTime Ticks that contains the time elapsed since the
            system has started, or (if <paramref name="unbiased"/> is <c>true</c>) the time
            the system has spent in the working state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.Permutations``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            (a,b),(c,d) -> (a,c),(a,d),(b,c),(b,d)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetArray``1(System.Collections.Generic.IEnumerable{``0},``0[]@)">
            <summary>
            Tries to fetch the underlying array from the given sequence. Tests for array, <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> and <see cref="T:VL.Lib.Collections.Spread`1"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="array">The underlying array.</param>
            <returns>True if the array could be fetched.</returns>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetArraySegment``1(System.Collections.Generic.IEnumerable{``0},System.ArraySegment{``0}@)">
            <summary>
            Tries to fetch the underlying array segment from the given sequence. Tests for array, <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> and <see cref="T:VL.Core.IHasMemory`1"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="segment">The underlying array segment.</param>
            <returns>True if the array segment could be fetched.</returns>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetMemory``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlyMemory{``0}@)">
            <summary>
            Tries to fetch the backing memory of the provided sequence. Tests for collections implementing <see cref="T:VL.Core.IHasMemory`1"/>, 
            array and <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            </summary>
            <typeparam name="T">The elment type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="memory">The content of the sequence as memory.</param>
            <returns>True if the memory could be fetched.</returns>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetSpan``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{``0}@)">
            <summary>
            Tries to expose the sequence as a <see cref="T:System.ReadOnlySpan`1"/>. Tests for collections implementing <see cref="T:VL.Core.IHasMemory`1"/>, 
            array and <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            </summary>
            <typeparam name="T">The elment type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="span">The content of the sequence exposed as a span.</param>
            <returns>True if the content could be exposed as a span.</returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions1.EnsureValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            create the value if not already stored for that key
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.ClampedElementAtIfNotEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>
            throws if input is empty. so please check that first
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.ClampedElementAtOrDefault``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>
            if count = 0 returns a default(T)
            </summary>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableStackExtensions.SequenceEqual``1(System.Collections.Immutable.ImmutableStack{``0},System.Collections.Immutable.ImmutableStack{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Same as <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/> but without any memory allocations when enumerating the stacks.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.PointF})">
            <summary>
            Returns the bounds of the given point cloud.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.RectangleF})">
            <summary>
            Returns the bounds of the given rectangle cloud.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Area(System.Drawing.SizeF)">
            <summary>
            Returns the area.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetCenter(System.Drawing.RectangleF)">
            <summary>
            Returns the center of this RectangleF.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetOnePixelRectangleForCenter(System.Drawing.PointF)">
            <summary>
            Returns a rectangle for given center position and 1 pixel size
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetRectangleForCenterAndSize(System.Drawing.PointF,System.Drawing.SizeF)">
            <summary>
            Returns a rectangle for given center position and size.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.ToRectangle(System.Drawing.RectangleF)">
            <summary>
            Returns a <see cref="T:System.Drawing.Rectangle">Rectangle</see> by casting the float components to integer.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.ToPoint(System.Drawing.PointF)">
            <summary>
            Returns a <see cref="T:System.Drawing.Point">Point</see> by casting the float components to integer.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Plus(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Translates a given <see cref="T:System.Drawing.PointF">p1</see> by a specified <see cref="T:System.Drawing.PointF">p2</see>.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Minus(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Translates a given <see cref="T:System.Drawing.PointF">p1</see> by a specified <see cref="T:System.Drawing.PointF">p2</see>.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetDistanceTo(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Returns the distance to another point.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetSquaredDistanceTo(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Returns the squared distance to another point. Good for comparisons.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Normalize(System.Drawing.PointF)">
            <summary>
            Normalizes the length
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetDistanceTo(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Returns the distance to another point.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformPoint(System.Drawing.Drawing2D.Matrix,System.Drawing.PointF)">
            <summary>
            Applies the transformation to a PointF
            </summary>
            <param name="t">A Matrix</param>
            <param name="p">The point to transform by the matrix t</param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformRectangle(System.Drawing.Drawing2D.Matrix,System.Drawing.Rectangle)">
            <summary>
            Applies the geometric transform represented by this Matrix to the
            given rectangle.
            </summary>
            <param name="t">A Matrix</param>
            <param name="rect">The rectangle to transform.</param>
            <returns>The transformed rectangle.</returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformRectangle(System.Drawing.Drawing2D.Matrix,System.Drawing.RectangleF)">
            <summary>
            Applies the geometric transform represented by this Matrix to the
            given rectangle.
            </summary>
            <param name="t">A Matrix</param>
            <param name="rect">The rectangle to transform.</param>
            <returns>The transformed rectangle.</returns>
        </member>
        <member name="T:System.SyncProgress`1">
            <summary>
            Provides an IProgress{T} that invokes callbacks for each reported progress value synchronously without using a synchronization context.
            See: https://stackoverflow.com/questions/37883297/can-i-await-on-iprogress-report
            </summary>
            <typeparam name="T">Specifies the type of the progress report value.</typeparam>
            <remarks>
            Any handler provided to the constructor or event handlers registered with
            the <see cref="E:System.SyncProgress`1.ProgressChanged"/> event are invoked synchronously by the caller.
            </remarks>
        </member>
        <member name="F:System.SyncProgress`1.m_handler">
            <summary>The handler specified to the constructor.  This may be null.</summary>
        </member>
        <member name="F:System.SyncProgress`1.m_invokeHandlers">
            <summary>A cached delegate used to post invocation to the synchronization context.</summary>
        </member>
        <member name="M:System.SyncProgress`1.#ctor">
            <summary>Initializes the <see cref="T:System.SyncProgress`1"/>.</summary>
        </member>
        <member name="M:System.SyncProgress`1.#ctor(System.Action{`0})">
            <summary>Initializes the <see cref="T:System.SyncProgress`1"/> with the specified callback.</summary>
            <param name="handler">
            A handler to invoke for each reported progress value.  This handler will be invoked
            in addition to any delegates registered with the <see cref="E:System.SyncProgress`1.ProgressChanged"/> event.
            Depending on the <see cref="T:System.Threading.SynchronizationContext"/> instance captured by 
            the <see cref="!:Progress"/> at construction, it's possible that this handler instance
            could be invoked concurrently with itself.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="handler"/> is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="E:System.SyncProgress`1.ProgressChanged">
            <summary>Raised for each reported progress value.</summary>
            <remarks>
            Handlers registered with this event will be invoked on the 
            <see cref="T:System.Threading.SynchronizationContext"/> captured when the instance was constructed.
            </remarks>
        </member>
        <member name="M:System.SyncProgress`1.OnReport(`0)">
            <summary>Reports a progress change.</summary>
            <param name="value">The value of the updated progress.</param>
        </member>
        <member name="M:System.SyncProgress`1.System#IProgress{T}#Report(`0)">
            <summary>Reports a progress change.</summary>
            <param name="value">The value of the updated progress.</param>
        </member>
        <member name="M:System.SyncProgress`1.InvokeHandlers(System.Object)">
            <summary>Invokes the action and event callbacks.</summary>
            <param name="state">The progress value.</param>
        </member>
    </members>
</doc>
