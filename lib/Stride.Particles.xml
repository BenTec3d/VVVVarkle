<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Stride.Particles</name>
    </assembly>
    <members>
        <member name="P:Stride.Particles.BoundingShapes.BoundingBoxStatic.Minimum">
            <summary>
            Lower corner of the AABB
            </summary>
            <userdoc>
            Lower corner of the AABB (left, bottom, back)
            </userdoc>
        </member>
        <member name="P:Stride.Particles.BoundingShapes.BoundingBoxStatic.Maximum">
            <summary>
            Upper corner of the AABB
            </summary>
            <userdoc>
            Upper corner of the AABB (right, top, front)
            </userdoc>
        </member>
        <member name="P:Stride.Particles.BoundingShapes.BoundingShape.DebugDraw">
            <summary>
            Should the Bounding shape's bounds be displayed as a debug draw
            </summary>
            <userdoc>
            Display the Bounding shape's boinds as a wireframe debug shape. Temporary feature (will be removed later)!
            </userdoc>
        </member>
        <member name="P:Stride.Particles.BoundingShapes.BoundingSphereStatic.Radius">
            <summary>
            Fixed radius of the <see cref="T:Stride.Particles.BoundingShapes.BoundingSphereStatic"/>
            </summary>
            <userdoc>
            Fixed radius of the bounding sphere. Gets calculated as a AABB, which is a cube with corners (-R, -R, -R) - (+R, +R, +R)
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Components.ParticleSystemComponent">
            <summary>
            Add a <see cref="P:Stride.Particles.Components.ParticleSystemComponent.ParticleSystem"/> to an <see cref="T:Stride.Engine.Entity"/>
            </summary>
        </member>
        <member name="P:Stride.Particles.Components.ParticleSystemComponent.ParticleSystem">
            <summary>
            The particle system associated with this component
            </summary>
            <userdoc>
            The Particle System associated with this component
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Components.ParticleSystemComponent.Color">
            <summary>
            The color shade will be applied to all particles (via their materials) during rendering.
            The shade acts as a color scale multiplication, making the color darker. White shade is neutral.
            </summary>
            <userdoc>
            Color shade (RGBA) will be multiplied to all particles' color in this particle system
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Components.ParticleSystemComponent.Speed">
            <summary>
            The speed scale at which the particle simulation runs. Increasing the scale increases the simulation speed,
            while setting it to 0 effectively pauses the simulation.
            </summary>
            <userdoc>
            The speed scale at which this particle system runs the simulation. Set it to 0 to pause it
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Components.ParticleSystemComponent.RenderGroup">
            <summary>
            The render group for this component.
            </summary>
        </member>
        <member name="T:Stride.Particles.Components.ParticleSystemControl">
            <summary>
            Edit-time controls for the <see cref="T:Stride.Particles.Components.ParticleSystemComponent"/>
            </summary>
        </member>
        <member name="P:Stride.Particles.Components.ParticleSystemControl.ResetSeconds">
            <summary>
            Resets the <see cref="T:Stride.Particles.ParticleSystem"/> every X seconds, starting the simulation over again. Setting it to 0 means the particle system won't be resetted
            </summary>
            <userdoc>
            Resets the particle system every X seconds, starting the simulation over again. Setting it to 0 means the particle system won't be resetted
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Components.ParticleSystemControl.Control">
            <summary>
            State control used to Play, Pause or Stop the <see cref="T:Stride.Particles.ParticleSystem"/>
            </summary>
            <userdoc>
            State control used to Play, Pause or Stop the particle system
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Components.ParticleSystemControl.ThumbnailWarmupTime">
            <summary>
            Warm-up time is the amount of time the system should spend in background pre-simulation when capturing the thumbnail
            </summary>
            <userdoc>
            Warm-up time is the amount of time the system should spend in background pre-simulation when capturing the thumbnail
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemControl.Update(System.Single,Stride.Particles.ParticleSystem)">
            <summary>
            Update the control with delta time. It will pause or restart the <see cref="T:Stride.Particles.ParticleSystem"/> if necessary
            </summary>
            <param name="dt">Delta time elapsed since the last update call</param>
            <param name="particleSystem">The <see cref="T:Stride.Particles.ParticleSystem"/> which this control should manage</param>
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Stride.Particles.Components.ParticleSystemSimulationProcessor"/> class.
            </summary>
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.OnSystemAdd">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.OnSystemRemove">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.OnEntityComponentAdding(Stride.Engine.Entity,Stride.Particles.Components.ParticleSystemComponent,Stride.Particles.Components.ParticleSystemSimulationProcessor.ParticleSystemComponentState)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.OnEntityComponentRemoved(Stride.Engine.Entity,Stride.Particles.Components.ParticleSystemComponent,Stride.Particles.Components.ParticleSystemSimulationProcessor.ParticleSystemComponentState)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.Draw(Stride.Rendering.RenderContext)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.GenerateComponentData(Stride.Engine.Entity,Stride.Particles.Components.ParticleSystemComponent)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Components.ParticleSystemSimulationProcessor.IsAssociatedDataValid(Stride.Engine.Entity,Stride.Particles.Components.ParticleSystemComponent,Stride.Particles.Components.ParticleSystemSimulationProcessor.ParticleSystemComponentState)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Components.ParticleSystemSimulationProcessor.ParticleSystemComponentState">
            <summary>
            Base component state for this processor. Every particle system requires a locator, so the <see cref="F:Stride.Particles.Components.ParticleSystemSimulationProcessor.ParticleSystemComponentState.TransformComponent"/> is mandatory
            </summary>
        </member>
        <member name="T:Stride.Particles.Components.StateControl">
            <summary>
            State control for the particle system
            </summary>
        </member>
        <member name="F:Stride.Particles.Components.StateControl.Play">
            <summary>
            The state is active and currently playing
            </summary>
        </member>
        <member name="F:Stride.Particles.Components.StateControl.Pause">
            <summary>
            The state is active, but currently not playing (paused)
            </summary>
        </member>
        <member name="F:Stride.Particles.Components.StateControl.Stop">
            <summary>
            The state is inactive
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.Initial3DRotationSeed.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Initializers.Initial3DRotationSeed.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.Initial3DRotationSeed.RotationQuaternionMin">
            <summary>
            The first orientation to interpolate from
            </summary>
            <userdoc>
            The first orientation to interpolate from
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.Initial3DRotationSeed.RotationQuaternionMax">
            <summary>
            The second orientation to interpolate to
            </summary>
            <userdoc>
            The second orientation to interpolate to
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Initializers.InitialColorParent">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialColorParent"/> is an initializer which sets the particle's initial color based on a followed (parent) particle's color
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialColorParent.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialColorParent.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialColorParent.ColorMin">
            <summary>
            The first color to interpolate from
            </summary>
            <userdoc>
            The first color to interpolate from
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialColorParent.ColorMax">
            <summary>
            The second color to interpolate to
            </summary>
            <userdoc>
            The second color to interpolate to
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialColorParent.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Initializers.InitialColorSeed.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialColorSeed.ColorMin">
            <summary>
            The first color to interpolate from
            </summary>
            <userdoc>
            The first color to interpolate from
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialColorSeed.ColorMax">
            <summary>
            The second color to interpolate to
            </summary>
            <userdoc>
            The second color to interpolate to
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Initializers.InitialDefaultFields">
            <summary>
            This initializer sets each field to its default value in case a custom initializer is not present.
            </summary>
        </member>
        <member name="T:Stride.Particles.Initializers.InitialDirectionSeed">
            <summary>
            Initializer which sets the initial velocity for particles based on RandomSeed information
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialDirectionSeed.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialDirectionSeed.DirectionMin">
            <summary>
            Lower direction value
            </summary>
            <userdoc>
            Lower direction value
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialDirectionSeed.DirectionMax">
            <summary>
            Upper direction value
            </summary>
            <userdoc>
            Upper direction value
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialDirectionSeed.DebugDraw">
            <summary>
            Should this Particle Module's bounds be displayed as a debug draw
            </summary>
            <userdoc>
            Display the Particle Module's bounds as a wireframe debug shape. Temporary feature (will be removed later)!
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Initializers.InitialOrderParent">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialOrderParent"/> is an initializer which sets the particle's spawn order based on a followed (parent) particle's order
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialOrderParent.ResetSimulation">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Initializers.InitialOrderParent.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialOrderParent.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Initializers.InitialOrderParent.RemoveControlGroup">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Initializers.InitialOrderParent.AddControlGroup">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialPositionArc">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialPositionArc"/> is an initializer which sets the particle's initial position along a line or an arc
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialPositionArc.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="F:Stride.Particles.Initializers.InitialPositionArc.Target">
            <summary>
            An arc initializer needs a second point so that it can position the particles in a line or arc between two locators
            </summary>
            <userdoc>
            An arc initializer needs a second point so that it can position the particles in a line or arc between two locators
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Initializers.InitialPositionArc.FallbackTarget">
            <summary>
            In case the <see cref="F:Stride.Particles.Initializers.InitialPositionArc.Target"/> is null, the <see cref="F:Stride.Particles.Initializers.InitialPositionArc.FallbackTarget"/> offset will be used
            </summary>
            <userdoc>
            In case the Target is null, the FallbackTarget offset will be used
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Initializers.InitialPositionArc.ArcHeight">
            <summary>
            The height of the arc in the center, which is also subject to scale and rotation if inherited
            </summary>
            <userdoc>
            The height of the arc in the center, which is also subject to scale and rotation if inherited
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Initializers.InitialPositionArc.Sequential">
            <summary>
            If <C>true</C> the particles will appear along the arc path in the order they are added.
            Otherwise, their positions will be random along the arc, not preserving the order of appearance.
            </summary>
            <userdoc>
            If true the particles will appear along the arc path in the order they are added.
            Otherwise, their positions will be random along the arc, not preserving the order of appearance.
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Initializers.InitialPositionArc.FixedLength">
            <summary>
            If positive, it will limit the number of possible positions where the particles can appear along the arc to the specified count.
            More particles will start appearing over from the biginning of the arc path.
            </summary>
            <userdoc>
            If positive, it will limit the number of possible positions where the particles can appear along the arc to the specified count.
            More particles will start appearing over from the biginning of the arc path.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionArc.PositionMin">
            <summary>
            The left bottom back corner of the box
            </summary>
            <userdoc>
            The left bottom back corner of the box
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionArc.PositionMax">
            <summary>
            The right upper front corner of the box
            </summary>
            <userdoc>
            The right upper front corner of the box
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionArc.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialPositionArc.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialPositionParent">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialPositionParent"/> is an initializer which sets the particle's initial position at the time of spawning
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialPositionParent.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionParent.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionParent.PositionMin">
            <summary>
            The left bottom back corner of the box
            </summary>
            <userdoc>
            The left bottom back corner of the box
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionParent.PositionMax">
            <summary>
            The right upper front corner of the box
            </summary>
            <userdoc>
            The right upper front corner of the box
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialPositionParent.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialPositionSeed">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialPositionSeed"/> is an initializer which sets the particle's initial position at the time of spawning
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialPositionSeed.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialPositionSeed.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionSeed.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionSeed.PositionMin">
            <summary>
            The left bottom back corner of the box
            </summary>
            <userdoc>
            The left bottom back corner of the box
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionSeed.PositionMax">
            <summary>
            The right upper front corner of the box
            </summary>
            <userdoc>
            The right upper front corner of the box
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Initializers.InitialPositionSeed.Interpolate">
            <summary>
            If set to <c>true</c> it will interpolate the particles between the old and the new position, rather than using only the new one
            </summary>
            <userdoc>
            If set to <c>true</c> it will interpolate the particles between the old and the new position, rather than using only the new one
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialPositionSeed.DebugDraw">
            <summary>
            Should this Particle Module's bounds be displayed as a debug draw
            </summary>
            <userdoc>
            Display the Particle Module's bounds as a wireframe debug shape. Temporary feature (will be removed later)!
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialPositionSeed.TryGetDebugDrawShape(Stride.Particles.DebugDraw.DebugDrawShape@,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,Stride.Core.Mathematics.Vector3@)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialRotationSeed">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialRotationSeed"/> is an initializer which sets the particle's rotation around the Z axis in clip space (camera-facing)
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialRotationSeed.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialRotationSeed.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialRotationSeed.AngularRotation">
            <summary>
            Angular rotation in degrees, positive value means clockwise
            </summary>
            <userdoc>
            Angular rotation in degrees, positive value means clockwise
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialRotationSeed.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialSizeParent">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialSizeParent"/> is an initializer which sets the particle's size based on a followed (parent) particle's size
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSizeParent.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialSizeParent.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialSizeParent.RandomSize">
            <summary>
            Minimum and maximum values for the size field
            </summary>
            <userdoc>
            Minimum and maximum values for the size field
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSizeParent.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Initializers.InitialSizeSeed.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialSizeSeed.RandomSize">
            <summary>
            Minimum and maximum values for the size field
            </summary>
            <userdoc>
            Minimum and maximum values for the size field
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Initializers.InitialSpawnOrder">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialSpawnOrder"/> is an initializer which assigns all particles an increasing number based on the order of their spawning
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSpawnOrder.ResetSimulation">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSpawnOrder.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSpawnOrder.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialSpawnOrderGroup">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialSpawnOrderGroup"/> is an initializer which assigns all particles an increasing number based on the order of their spawning while keeping all particles spawned in the same frame in a separate spawn group (this is important for ribbons)
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSpawnOrderGroup.ResetSimulation">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSpawnOrderGroup.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialSpawnOrderGroup.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialVelocityParent">
            <summary>
            The <see cref="T:Stride.Particles.Initializers.InitialVelocityParent"/> is an initializer which sets the particle's velocity based on a followed (parent) particle's velocity
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialVelocityParent.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocityParent.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocityParent.ParentVelocityFactor">
            <summary>
            The factor (percentage) for parent's velocity inheritance
            </summary>
            <userdoc>
            The factor (percentage) for parent's velocity inheritance
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocityParent.VelocityMin">
            <summary>
            The left bottom back corner of the box
            </summary>
            <userdoc>
            The left bottom back corner of the box
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocityParent.VelocityMax">
            <summary>
            The right upper front corner of the box
            </summary>
            <userdoc>
            The right upper front corner of the box
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Initializers.InitialVelocityParent.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Initializers.InitialVelocitySeed">
            <summary>
            Initializer which sets the initial velocity for particles based on RandomSeed information
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocitySeed.SeedOffset">
            <summary>
            The seed offset used to match or separate random values
            </summary>
            <userdoc>
            The seed offset used to match or separate random values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocitySeed.VelocityMin">
            <summary>
            Lower velocity value
            </summary>
            <userdoc>
            Lower velocity value
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocitySeed.VelocityMax">
            <summary>
            Upper velocity value
            </summary>
            <userdoc>
            Upper velocity value
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.InitialVelocitySeed.DebugDraw">
            <summary>
            Should this Particle Module's bounds be displayed as a debug draw
            </summary>
            <userdoc>
            Display the Particle Module's bounds as a wireframe debug shape. Temporary feature (will be removed later)!
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Initializers.ParticleChildInitializer">
            <summary>
            Base class for initializers which reference a parent particle emitter
            </summary>
        </member>
        <member name="F:Stride.Particles.Initializers.ParticleChildInitializer.Parent">
            <summary>
            Referenced parent emitter
            </summary>
        </member>
        <member name="F:Stride.Particles.Initializers.ParticleChildInitializer.parentName">
            <summary>
            Referenced parent emitter's name
            </summary>
        </member>
        <member name="F:Stride.Particles.Initializers.ParticleChildInitializer.isParentNameDirty">
            <summary>
            <c>true</c> is the parent's name has changed or the particle system has been invalidated
            </summary>
        </member>
        <member name="P:Stride.Particles.Initializers.ParticleChildInitializer.ParentName">
            <summary>
            Name by which to reference a followed (parent) emitter
            </summary>
            <userdoc>
            Name by which to reference a followed (parent) emitter
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.ParticleChildInitializer.ParentSeedOffset">
            <summary>
            The parent seed offset is used to determine which particle from the pool should be picked as a parent in case there is no control group
            </summary>
            <userdoc>
            The parent seed offset is used to determine which particle from the pool should be picked as a parent in case there is no control group
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Initializers.ParticleChildInitializer.ParentControlFlag">
            <summary>
            Some initializers require fine control between parent and child emitters. Use the control group to assign such meta-fields.
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.ParticleChildInitializer.GetSpawnControlField">
            <summary>
            Gets a field accessor to the parent emitter's spawn control field, if it exists
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.Initializers.ParticleChildInitializer.SetParentTRS(Stride.Particles.ParticleTransform,Stride.Particles.ParticleSystem)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Initializers.ParticleChildInitializer.InvalidateRelations">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Initializers.ParticleChildInitializer.RemoveControlGroup">
            <summary>
            Removes the old required control group field from the parent emitter's pool
            </summary>
        </member>
        <member name="M:Stride.Particles.Initializers.ParticleChildInitializer.AddControlGroup">
            <summary>
            Adds the required control group field to the parent emitter's pool
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Stride.Particles.Initializers.ParticleInitializer.Initialize(Stride.Particles.ParticlePool,System.Int32,System.Int32,System.Int32)" -->
        <member name="T:Stride.Particles.Initializers.SpawnOrderConst">
            <summary>
            Spawn order can be additionally subdivided in groups
            </summary>
        </member>
        <member name="T:Stride.Particles.Materials.ParticleMaterial">
            <summary>
            Base class for the particle materials which uses a dynamic effect compiler to generate shaders at runtime
            </summary>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterial.IsInitialized">
            <summary>
            True if <see cref="M:Stride.Particles.Materials.ParticleMaterial.InitializeCore(Stride.Rendering.RenderContext)"/> has been called
            </summary>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterial.HasVertexLayoutChanged">
            <summary>
            Indicates if the vertex layout required by this material has changed since the last time <see cref="M:Stride.Particles.Materials.ParticleMaterial.UpdateVertexBuilder(Stride.Particles.VertexLayouts.ParticleVertexBuilder)"/> was called
            </summary>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterial.EffectName">
            <summary>
            Sets the name of the effect or shader which the material will use
            </summary>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterial.PrepareVertexLayout(Stride.Particles.ParticlePoolFieldsList)">
            <summary>
            Prepares the material for drawing the current frame with the current <see cref="T:Stride.Particles.VertexLayouts.ParticleVertexBuilder"/> and <see cref="!:ParticleSorter"/>
            </summary>
            <param name="fieldsList">A container for the <see cref="T:Stride.Particles.ParticlePool"/> which can poll if a certain field exists as an attribute</param>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterial.UpdateVertexBuilder(Stride.Particles.VertexLayouts.ParticleVertexBuilder)">
            <summary>
            Updates the required fields for this frame in the vertex buffer builder.
            If nothing has changed since the last frame and the vertex layout is the same, do not add any new required fields
            </summary>
            <param name="vertexBuilder">The target vertex buffer builder</param>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterial.Setup(Stride.Rendering.RenderContext)">
            <summary>
            Setups the current material using the graphics device.
            </summary>
            <param name="graphicsDevice">Graphics device to setup</param>
            <param name="viewMatrix">The camera's View matrix</param>
            <param name="projMatrix">The camera's Projection matrix</param>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterial.ForceUpdate">
            <summary>
            Forces the material update, potentionally recreating the effect
            </summary>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterial.SetupPipeline(Stride.Rendering.RenderContext,Stride.Graphics.PipelineStateDescription)">
            <summary>
            Setup the pipeline state object.
            </summary>
            <param name="renderContext"></param>
            <param name="pipelineState"></param>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterial.PatchVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Particles.Sorters.ParticleList@)">
            <summary>
            Patch the particle's vertex buffer which was already built by the <see cref="T:Stride.Particles.ShapeBuilders.ShapeBuilder"/>
            This involes animating hte uv coordinates and filling per-particle fields, such as the color field
            </summary>
            <param name="bufferState">The particle buffer state which is used to build the assigned vertex buffer</param>
            <param name="invViewX">Unit vector X (right) in camera space, extracted from the inverse view matrix</param>
            <param name="invViewY">Unit vector Y (up) in camera space, extracted from the inverse view matrix</param>
            <param name="sorter">Particle enumerator which can be iterated and returns sported particles</param>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterial.InitializeCore(Stride.Rendering.RenderContext)">
            <summary>
            Initializes the core of the material, such as the shader generator and the parameter collection
            </summary>
            <param name="context">The current <see cref="T:Stride.Rendering.RenderContext"/></param>
        </member>
        <member name="T:Stride.Particles.Materials.ParticleMaterialComputeColor">
            <summary>
            <see cref="T:Stride.Particles.Materials.ParticleMaterialComputeColor"/> uses a <see cref="T:Stride.Rendering.Materials.IComputeColor"/> tree to calculate the pixel's emissive value
            </summary>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialComputeColor.ComputeColor">
            <summary>
            <see cref="T:Stride.Rendering.Materials.IComputeColor"/> allows several channels to be blended together, including textures, vertex streams and fixed values.
            Emissive Map should be allowed to be None because some particles might not need to render, but be used as parents for other particle systems
            </summary>
            <userdoc>
            Emissive component ignores light and defines a fixed color this particle should use (emit) when rendered.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialComputeColor.UVBuilder">
            <summary>
            <see cref="T:Stride.Particles.Materials.UVBuilder"/> defines how the base coordinates of the particle shape should be modified for texture scrolling, animation, etc.
            </summary>
            <userdoc>
            If left blank, the texture coordinates will be the original ones from the shape builder, usually (0, 0, 1, 1). Or you can define a custom texture coordinate builder which modifies the original coordinates for the sprite.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialComputeColor.ForceTexCoords">
            <summary>
            Forces the creation of texture coordinates as vertex attribute
            </summary>
            <userdoc>
            Forces the creation of texture coordinates as vertex attribute
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialComputeColor.InitializeCore(Stride.Rendering.RenderContext)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialComputeColor.Setup(Stride.Rendering.RenderContext)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialComputeColor.UpdateShaders(Stride.Graphics.GraphicsDevice)">
            <summary>
            Polls the shader generator if the shader code has changed and has to be reloaded
            </summary>
            <param name="graphicsDevice">The current <see cref="T:Stride.Graphics.GraphicsDevice"/></param>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialComputeColor.UpdateVertexBuilder(Stride.Particles.VertexLayouts.ParticleVertexBuilder)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialComputeColor.PatchVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Particles.Sorters.ParticleList@)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Materials.ParticleMaterialSimple">
            <summary>
            Simple base for most of the particle material classes which uses additive-alpha blending, face culling and setups the color vertex stream
            </summary>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialSimple.AlphaAdditive">
            <summary>
            Shows if the particles should be rendered as alhpa-blended, additive or something in-between (lerp between the two methods)
            </summary>
            <userdoc>
            Defines if the particles should be rendered as alpha-blended (0), additive (1) or something in-between (any value between 0 and 1)
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialSimple.ZOffset">
            <summary>
            Adjusts the depth of the particle in regard to opaque objects
            </summary>
            <userdoc>
            Adjusts the depth of the particle in regard to opaque objects
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialSimple.SoftEdgeDistance">
            <summary>
            If positive, soft particle edges will be calculated with maximum distance of the value set.
            </summary>
            <userdoc>
            If positive, soft particle edges will be calculated with maximum distance of the value set.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialSimple.FaceCulling">
            <summary>
            Allows the particle shape to be back- or front-face culled.
            </summary>
            <userdoc>
            The default option is no culling, other possible options are back-face culling and front-face culling. Culling both faces at the same time is not an option.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.ParticleMaterialSimple.HasColorField">
            <summary>
            Indicates if this material requires a color field in the vertex stream
            </summary>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialSimple.PrepareVertexLayout(Stride.Particles.ParticlePoolFieldsList)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialSimple.ForceUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialSimple.Setup(Stride.Rendering.RenderContext)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Materials.ParticleMaterialSimple.PatchVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Particles.Sorters.ParticleList@)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Materials.UVBuilder">
            <summary>
            Base class for building and animating the texture coordinates in a particle vertex buffer stream
            </summary>
        </member>
        <member name="M:Stride.Particles.Materials.UVBuilder.BuildUVCoordinates(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Particles.Sorters.ParticleList@,Stride.Particles.VertexLayouts.AttributeDescription)">
            <summary>
            Enhances or animates the texture coordinates using already existing base coordinates of (0, 0, 1, 1) or similar
            (base texture coordinates may differ depending on the actual shape)
            </summary>
            <param name="bufferState">The particle buffer state which is used to build the assigned vertex buffer</param>
            <param name="sorter"><see cref="!:ParticleSorter"/> to use to iterate over all particles drawn this frame</param>
            <param name="texCoordsDescription">Attribute description of the texture coordinates in the current vertex layout</param>
        </member>
        <member name="T:Stride.Particles.Materials.UVBuilderFlipbook">
            <summary>
            Animates the texture coordinates in a flipbook fashion, based on the particle's life
            The order of the frames is left to right, top to bottom
            The flipbook assumes uniform sizes for all frames
            </summary>
        </member>
        <member name="P:Stride.Particles.Materials.UVBuilderFlipbook.XDivisions">
            <summary>
            Number of columns (cells per row)
            </summary>
            <userdoc>
            How many columns (divisions along the width/X-axis) should the flipbook have.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.UVBuilderFlipbook.YDivisions">
            <summary>
            Number of rows (cells per column)
            </summary>
            <userdoc>
            How many rows (divisions along the height/Y-axis) should the flipbook have.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.UVBuilderFlipbook.StartingFrame">
            <summary>
            Position of the starting frame, 0-based indexing
            </summary>
            <userdoc>
            Index of the starting frame in a 0-based indexing. Frames increase to the right first, before going down after the end of a row.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.UVBuilderFlipbook.AnimationSpeed">
            <summary>
            Number of frames to change over the particle life
            </summary>
            <userdoc>
            How many frames does the animation have over the particle's lifetime. Speed = X * Y means all frames are played exactly once.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Materials.UVBuilderFlipbook.BuildUVCoordinates(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Particles.Sorters.ParticleList@,Stride.Particles.VertexLayouts.AttributeDescription)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Materials.UVBuilderScroll">
            <summary>
            Animates the texture coordinates starting with one rectangle and scrolling/zooming it to an ending rectangle over the particle's life
            </summary>
        </member>
        <member name="P:Stride.Particles.Materials.UVBuilderScroll.StartFrame">
            <summary>
            Starting sub-region (rectangle) for the scroll
            </summary>
            <userdoc>
            The rectangular sub-region of the texture where the scrolling should start, given as (Xmin, Ymin, Xmax, Ymax) ( (0, 0, 1, 1) being the entire texture). Numbers also can be negative or bigger than 1.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Materials.UVBuilderScroll.EndFrame">
            <summary>
            Ending sub-region (rectangle) for the scroll
            </summary>
            <userdoc>
            The rectangular sub-region of the texture where the scrolling should end at the particle life's end, given as (Xmin, Ymin, Xmax, Ymax) ( (0, 0, 1, 1) being the entire texture). Numbers also can be negative or bigger than 1.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Materials.UVBuilderScroll.BuildUVCoordinates(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Particles.Sorters.ParticleList@,Stride.Particles.VertexLayouts.AttributeDescription)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Particle">
            <summary>
            The most basic unit of a <see cref="T:Stride.Particles.ParticleSystem"/>
            You can access individual fields with a <see cref="T:Stride.Particles.ParticleFieldAccessor"/>
            </summary>
        </member>
        <member name="F:Stride.Particles.Particle.Pointer">
            <summary>
            Pointer to the particle data block
            </summary>
        </member>
        <member name="M:Stride.Particles.Particle.#ctor(System.IntPtr)">
            <summary>
            Creates a particle from a raw pointer, assuming the pointer references valid particle data block
            </summary>
            <param name="pointer"></param>
        </member>
        <member name="M:Stride.Particles.Particle.Invalid">
            <summary>
            Creates an invalid <see cref="T:Stride.Particles.Particle"/>. Accessing the invalid <see cref="T:Stride.Particles.Particle"/> is not resticted by the engine.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.Particle.Get``1(Stride.Particles.ParticleFieldAccessor{``0})">
            <summary>
            Gets the particle's field value. However, you should try to use the indexer wherever possible.
            </summary>
            <typeparam name="T">The field type.</typeparam>
            <param name="accessor">The field accessor</param>
            <returns>The field value.</returns>
        </member>
        <member name="M:Stride.Particles.Particle.Set``1(Stride.Particles.ParticleFieldAccessor{``0},``0@)">
            <summary>
            Sets the particle's field to a value. However, you should try to use the indexer wherever possible.
            </summary>
            <typeparam name="T">The field type.</typeparam>
            <param name="accessor">The field accessor</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:Stride.Particles.Particle.Set``1(Stride.Particles.ParticleFieldAccessor{``0},``0)">
            <summary>
            Sets the particle's field to a value. However, you should try to use the indexer wherever possible.
            </summary>
            <typeparam name="T">The field type.</typeparam>
            <param name="accessor">The field accessor</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:Stride.Particles.Particle.op_Equality(Stride.Particles.Particle,Stride.Particles.Particle)">
            <summary>
            Checks if the two particles point to the same pointer.
            </summary>
            <param name="particleLeft">Left side particle to compare</param>
            <param name="particleRight">Right side particle to compare</param>
            <returns></returns>
        </member>
        <member name="T:Stride.Particles.ParticleEmitter">
            <summary>
            The <see cref="T:Stride.Particles.ParticleEmitter"/> is the base manager for any given pool of particles, holding all particles and
            initializers, updaters, spawners, materials and shape builders associated with the particles.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.disposed">
            <summary>
            Used to indicate if Dispose(...) has been called already
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.sortingPolicy">
            <summary>
            The sorting policy we used for the <see cref="F:Stride.Particles.ParticleEmitter.ParticleSorter"/>
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.particlesToSpawn">
            <summary>
            Number of particles waiting to be spawned
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.pool">
            <summary>
            The pool contains all particles in the current <see cref="T:Stride.Particles.ParticleEmitter"/>
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.ParticleSorter">
            <summary>
            Enumerator which accesses all relevant particles in a sorted manner
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.RandomSeedGenerator">
            <summary>
            The RNG provides an easy seed-based random numbers
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.randomSeedMethod">
            <summary>
            RNG based on time uses the clock ticks and is almost always guaranteed to use different generators
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.simulationSpace">
            <summary>
            The default simulation space is World.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.hasBeenInitialized">
            <summary>
            Some parameters should be initialized when the emitter first runs, rather than in the constructor
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.particleLifetime">
            <summary>
            Particles will live for a number of seconds between these two values
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.DelayParticleDeath">
            <summary>
            If positive, forces particles to stay one frame more when they are about ot expire
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.requiredFields">
            <summary>
            A list of the required particle fields for the <see cref="T:Stride.Particles.ParticlePool"/>
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.maxParticlesOverride">
            <summary>
            If more than 0, the maxParticlesOverride will override the estimate for <see cref="P:Stride.Particles.ParticleEmitter.MaxParticles"/>
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.VertexBuilder">
            <summary>
            The vertex builder is used for rendering, and it builds the actual vertex buffer stream from particle data
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.emitterName">
            <summary>
            Optional name for the emitter, so that it can be referenced from other emitters
            </summary>
            <userdoc>
            Optional name for the emitter, so that it can be referenced from other emitters
            </userdoc>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.cachedParentSystem">
            <summary>
            Cached parent particle system, used for notifications
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.CachedParticleSystem">
            <summary>
            Cached parent particle system, used for notifications
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.#ctor">
            <summary>
            Default constructor. Initializes the pool and all collections contained in the <see cref="T:Stride.Particles.ParticleEmitter"/>
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.LivingParticles">
            <summary>
            Gets the current living particles from this emitter's pool
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.MaxParticles">
            <summary>
            Maximum number of particles this <see cref="T:Stride.Particles.ParticleEmitter"/> can have at any given time
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.CanEmitParticles">
            <summary>
            Indicates if the emitter is allowed to emit new particles or not.
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.Enabled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Stride.Particles.ParticleEmitter"/> is enabled.
            </summary>
            <value>
              <c>true</c> if enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.EmitterName">
            <summary>
            The emitter name is used to uniquely identify this emitter within the same particle system
            </summary>
            <userdoc>
            The emitter name is used to uniquely identify this emitter within the same particle system
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.MaxParticlesOverride">
            <summary>
            Maximum particles (if positive) overrides the maximum particle count limitation
            </summary>
            <userdoc>
            Leave it 0 for unlimited (automatic) pool size. If positive, it limits the maximum number of living particles this Emitter can have at any given time.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.SimulationSpace">
            <summary>
            Simulation space defines if the particles should be born in world space, or local to the emitter
            </summary>
            <userdoc>
            World space particles persist in world space after they are born and do not automatically change with the Emitter. Local space particles persist in the Emitter's local space and follow it whenever the Emitter's locator changes.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.RandomSeedMethod">
            <summary>
            Random numbers in the <see cref="T:Stride.Particles.ParticleSystem"/> are generated based on a seed, which in turn can be generated using several methods.
            </summary>
            <userdoc>
            All random numbers in the particle system are based on a seed. If you use deterministic seeds, your particles will always behave the same way every time you start the simulation.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.DrawPriority">
            <summary>
            DrawPriority is used to sort emitters at the same position based on a user defined key and determine the order in which they will be drawn 
            </summary>
            <userdoc>
            DrawPriority determines draw order within the same particle system. Higher priority appears on the top.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.SortingPolicy">
            <summary>
            How and if particles are sorted, and how they are access during rendering
            </summary>
            <userdoc>
            Choose if the particles should be soretd by depth (visually correct), age or not at all (fastest, good for additive blending)
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.ShapeBuilder">
            <summary>
            The <see cref="T:Stride.Particles.ShapeBuilders.ShapeBuilder"/> expands all living particles to vertex buffers for rendering
            </summary>
            <userdoc>
            The shape defines how each particle is expanded when rendered (camera-facing billboards, oriented quads, ribbons, etc.)
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleEmitter.Material">
            <summary>
            The <see cref="T:Stride.Particles.Materials.ParticleMaterial"/> may update the vertex buffer, and it also applies the <see cref="T:Stride.Graphics.Effect"/> required for rendering
            </summary>
            <userdoc>
            Material defines what effects, textures, coloring and other techniques are used when rendering the particles.
            </userdoc>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.Spawners">
            <summary>
            List of <see cref="T:Stride.Particles.Spawners.ParticleSpawner"/> to spawn particles in this <see cref="T:Stride.Particles.ParticleEmitter"/>
            </summary>
            <userdoc>
            Spawners define when, how, and how many particles are spawned. There can be several spawners.
            </userdoc>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.Initializers">
            <summary>
            List of <see cref="T:Stride.Particles.Initializers.ParticleInitializer"/> within thie <see cref="T:Stride.Particles.ParticleEmitter"/>. Adjust <see cref="F:Stride.Particles.ParticleEmitter.requiredFields"/> automatically
            </summary>
            <userdoc>
            Initializers set initial values for fields of particles which just spawned. Have no effect on already-spawned particles.
            </userdoc>
        </member>
        <member name="F:Stride.Particles.ParticleEmitter.Updaters">
            <summary>
            List of <see cref="T:Stride.Particles.Modules.ParticleUpdater"/> within thie <see cref="T:Stride.Particles.ParticleEmitter"/>. Adjust <see cref="F:Stride.Particles.ParticleEmitter.requiredFields"/> automatically
            </summary>
            <userdoc>
            Updaters change the fields of all living particles every frame, like position, velocity, color, size etc.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.PoolChangedNotification">
            <summary>
            If the particle pool has changed the sorter must also be updated to reflect those changes
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.ModulesChanged(System.Object,Stride.Core.Collections.FastTrackingCollectionChangedEventArgs@)">
            <summary>
            Notification that the modules (plugins) have changed.
            Pool's fields may need to be updated if new are required or old ones are no longer needed.
            </summary>
            <param name="sender">Sender</param>
            <param name="e">Event arguments</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.SpawnersChanged(System.Object,Stride.Core.Collections.FastTrackingCollectionChangedEventArgs@)">
            <summary>
            Spawners have changed.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.UpdatePaused(Stride.Particles.ParticleSystem)">
            <summary>
            Call this update when the <see cref="T:Stride.Particles.ParticleSystem"/> is paused to only update the renreding information
            </summary>
            <param name="parentSystem">The parent <see cref="T:Stride.Particles.ParticleSystem"/> containing this emitter</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.PreUpdate">
            <summary>
            Updates all data changes before the emitter is updated this frame.
            This method is not thread-safe!
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.Update(System.Single,Stride.Particles.ParticleSystem)">
            <summary>
            Updates the emitter and all its particles, and applies all updaters and spawners.
            </summary>
            <param name="dt">Delta time, elapsed time since the last call, in seconds</param>
            <param name="parentSystem">The parent <see cref="T:Stride.Particles.ParticleSystem"/> containing this emitter</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.DelayedInitialization(Stride.Particles.ParticleSystem)">
            <summary>
            Some parameters should be initialized when the emitter first runs, rather than in the constructor
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.ResetSimulation">
            <summary>
            Resets the simulation, deleting all particles and starting from Time = 0
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.UpdateLocations(Stride.Particles.ParticleSystem)">
            <summary>
            Updates the location matrices of all elements. Needs to be called even when the particle system is paused for updating the render positions
            </summary>
            <param name="parentSystem"><see cref="T:Stride.Particles.ParticleSystem"/> containing this emitter</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.EnsurePoolCapacity">
            <summary>
            Should be called before the other methods from <see cref="M:Stride.Particles.ParticleEmitter.Update(System.Single,Stride.Particles.ParticleSystem)"/> to ensure the pool has sufficient capacity to handle all particles.
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.MoveAndDeleteParticles(System.Single)">
            <summary>
            Should be called before <see cref="M:Stride.Particles.ParticleEmitter.ApplyParticleUpdaters(System.Single)"/> to ensure dead particles are removed before they are updated
            </summary>
            <param name="dt">Delta time, elapsed time since the last call, in seconds</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.ApplyParticleUpdaters(System.Single)">
            <summary>
            Should be called before <see cref="M:Stride.Particles.ParticleEmitter.SpawnNewParticles(System.Single)"/> to ensure new particles are not moved the frame they spawn
            </summary>
            <param name="dt">Delta time, elapsed time since the last call, in seconds</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.ApplyParticlePostUpdaters(System.Single)">
            <summary>
            Should be called after <see cref="M:Stride.Particles.ParticleEmitter.SpawnNewParticles(System.Single)"/> to ensure ALL particles are updated, not only the old ones
            </summary>
            <param name="dt">Delta time, elapsed time since the last call, in seconds</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.SpawnNewParticles(System.Single)">
            <summary>
            Spawns new particles and in general should be one of the last methods to call from the <see cref="M:Stride.Particles.ParticleEmitter.Update(System.Single,Stride.Particles.ParticleSystem)"/> method
            </summary>
            <param name="dt">Delta time, elapsed time since the last call, in seconds</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.AddRequiredField(Stride.Particles.ParticleFieldDescription)">
            <summary>
            Add a particle field required by some dependent module. If the module already exists in the pool, only its reference counter is increased.
            </summary>
            <param name="description"></param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.RemoveRequiredField(Stride.Particles.ParticleFieldDescription)">
            <summary>
            Remove a particle field no longer required by a dependent module. It only gets removed from the pool if it reaches 0 reference counters.
            </summary>
            <param name="description"></param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.PrepareForDraw(System.Boolean@,System.Int32@,System.Int32@)">
            <summary>
            <see cref="M:Stride.Particles.ParticleEmitter.PrepareForDraw(System.Boolean@,System.Int32@,System.Int32@)"/> prepares and updates the Material, ShapeBuilder and VertexBuilder if necessary
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.BuildVertexBuffer(System.IntPtr,Stride.Core.Mathematics.Matrix@,Stride.Core.Mathematics.Matrix@)">
            <summary>
            Build the vertex buffer from particle data
            </summary>
            <param name="sharedBufferPtr">The shared vertex buffer position where the particle data should be output</param>
            <param name="invViewMatrix">The current camera's inverse view matrix</param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.EmitParticles(System.Int32)">
            <summary>
            Requests the emitter to spawn several new particles.
            The particles are buffered and will be spawned during the <see cref="M:Stride.Particles.ParticleEmitter.Update(System.Single,Stride.Particles.ParticleSystem)"/> step
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.SimulationSpaceChanged">
            <summary>
            Changes the particle fields whenever the simulation space changes (World to Local or Local to World)
            This is a strictly debug feature so it (probably) won't be invoked during the game (unless changing the simulation space is intended?)
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleEmitter.InvalidateRelations">
            <summary>
            Invalidates relation of this emitter to any other emitters that might be referenced
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleField.Offset">
            <summary>
            Offset of the field from the particle's position
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleField.Size">
            <summary>
            Size of the field
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Position">
            <summary>
            Particle position in 3D space
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.OldPosition">
            <summary>
            Particle position from the last frame in 3D space, updated every frame if the particle has a Position field
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Direction">
            <summary>
            Particle direction, or offset, in 3D space, calculated from the particle's position
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Quaternion">
            <summary>
            Quaternion rotation, for particles which have rotation in 3D
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Rotation">
            <summary>
            Angular rotation, in RADIANS, for particles which only have 1 axis of rotation
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Velocity">
            <summary>
            Particle velocity in 3D space
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Size">
            <summary>
            Particle uniform size. If particles are rendered as a 2D quads or 3D meshes, these extra dimensions can be set on the material side.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.RandomSeed">
            <summary>
            Random seed, for generating fast random values in runtime.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.RemainingLife">
            <summary>
            Particle remaining lifetime. When it reaches 0, the particle dies.
            Remaining life is easier to work with because it is an absolute value. Total life needs to know what the maximum life is.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Rgba">
            <summary>
            Particle color, in RGBA.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.Order">
            <summary>
            Order of the particle, which can be based on spawn order or something else
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.ChildOrder">
            <summary>
            Order of the particle's children, which is based on their spawn order
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.CollisionControl">
            <summary>
            Provides control flags for particles which have collision enabled
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleFields.ChildrenFlags">
            <summary>
            ChildrenFlags is used to store meta-data for the dependent particles
            </summary>
        </member>
        <member name="T:Stride.Particles.ParticleModule">
            <summary>
            The <see cref="T:Stride.Particles.ParticleModule"/> is a base class for all plugins (initializers and updaters) used by the emitter
            Each plugin operates over one or several <see cref="T:Stride.Particles.ParticleFields"/> updating or setting up the particle state
            Additionally, each plugin can inherit some properties from the parent particle system, which are usually passed by the user.
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleModule.Enabled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Stride.Particles.ParticleModule"/> is enabled.
            </summary>
            <value>
              <c>true</c> if enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Stride.Particles.ParticleModule.ResetSimulation">
            <summary>
            Resets the current state to the module's initial state
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleModule.TryGetDebugDrawShape(Stride.Particles.DebugDraw.DebugDrawShape@,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,Stride.Core.Mathematics.Vector3@)">
            <summary>
            Attepmts to get a debug shape (shape type and location matrix) for the current module in order to display its boundaries better
            </summary>
            <param name="debugDrawShape">Type of the debug draw shape</param>
            <param name="translation">Translation of the shape</param>
            <param name="rotation">Rotation of the shape</param>
            <param name="scale">Scaling of the shape</param>
            <returns></returns>
        </member>
        <member name="F:Stride.Particles.ParticleModule.RequiredFields">
            <summary>
            A list of fields required by the module to operate properly.
            Please fill it during construction time.
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleModule.SetParentTRS(Stride.Particles.ParticleTransform,Stride.Particles.ParticleSystem)">
            <summary>
            Sets the parent (particle system's) translation, rotation and scale (uniform)
            The module can choose to inherit, use or ignore any of the elements
            </summary>
            <param name="transform"><see cref="T:Stride.Particles.ParticleSystem"/>'s transform (from the Transform component) or identity if local space is used</param>
            <param name="parent">The parent <see cref="T:Stride.Particles.ParticleSystem"/></param>
        </member>
        <member name="M:Stride.Particles.ParticleModule.InvalidateRelations">
            <summary>
            Invalidates relation of this emitter to any other emitters that might be referenced
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleModule.PreUpdate">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.ParticlePool">
            <summary>
            The <see cref="T:Stride.Particles.ParticlePool"/> is a class which manages an unmanaged memory block used for the particles.
            The maximum required size calculated on the number of particles and their fields' sizes is calculated every time the sizes or the count change
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticlePool.ListPolicy.Ring">
            <summary>
            New particles are allocated from the next free index which loops when it reaches the end of the list.
            The pool doesn't care about dead particles - they don't move and get overwritten by new particles.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticlePool.ListPolicy.Stack">
            <summary>
            New particles are allocated at the top of the stack. Dead particles are swapped out with the top particle.
            The stack stays small but order of the particles gets scrambled.
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticlePool.nextFreeIndex">
            <summary>
            For ring implementations, the index just increases, looping when it reaches max count.
            For stack implementations, the index points to the top of the stack and can reach 0 when there are no living particles.
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticlePool.#ctor(System.Int32,System.Int32,Stride.Particles.ParticlePool.ListPolicy)">
            <summary>
            <see cref="T:Stride.Particles.ParticlePool"/> constructor
            </summary>
            <param name="size">Initial size in bytes of a single particle</param>
            <param name="capacity">Initial capacity (maximum number of particles) of the pool</param>
            <param name="listPolicy">List policy - stack (living particles are in the front) or ring</param>
        </member>
        <member name="P:Stride.Particles.ParticlePool.NextFreeIndex">
            <summary>
            <see cref="P:Stride.Particles.ParticlePool.NextFreeIndex"/> points to the next index ready for allocation, between 0 and <see cref="P:Stride.Particles.ParticlePool.ParticleCapacity"/> - 1.
            In case of stack list the <see cref="P:Stride.Particles.ParticlePool.NextFreeIndex"/> equals the number of living particles in the pool.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Stride.Particles.ParticlePool.ParticleSize" -->
        <member name="P:Stride.Particles.ParticlePool.AvailableParticles">
            <summary>
            Gets how many more particles can be spawned
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticlePool.LivingParticles">
            <summary>
            Get the number of living (active) particles
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticlePool.ParticleData">
            <summary>
            ParticleData is where the memory block (particle pool) actually resides.
            Its size equals <see cref="P:Stride.Particles.ParticlePool.ParticleSize"/> * <see cref="P:Stride.Particles.ParticlePool.ParticleCapacity"/>
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticlePool.ParticleCapacity">
            <summary>
            The maximum allowed number of particles in this <see cref="T:Stride.Particles.ParticlePool"/>.
            Use <see cref="M:Stride.Particles.ParticlePool.SetCapacity(System.Int32)"/> if you need to change it.
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticlePool.SetCapacity(System.Int32)">
            <summary>
            Set a different capacity (maximum <see cref="T:Stride.Particles.Particle"/> count for this pool)
            Whenever possible, existing particles will be copied and continue simulation
            </summary>
            <param name="newCapacity">New maximum capacity</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.ReallocatePool(System.Int32,System.Int32,Stride.Particles.ParticlePool.CopyParticlePoolDelegate)">
            <summary>
            Moves the particle pool data to a new location, copying existing particles where possible
            </summary>
            <param name="newSize">New size for a single particle</param>
            <param name="newCapacity">New capacity (maximum number of particles)</param>
            <param name="poolCopy">Method to use for copying the particle data</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.Reset">
            <summary>
            Clears all particle fields, but keeps the particle capacity the same.
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticlePool.CopyParticleData(System.Int32,System.Int32)">
            <summary>
            Copy data from one particle index to another
            </summary>
            <param name="dst">Index of the destination particle</param>
            <param name="src">Index of the source particle</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.FromIndex(System.Int32)">
            <summary>
            Get a particle from its index in the pool
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.AddParticle">
            <summary>
            Add a new particle to the pool. Doesn't worry about initialization.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.RemoveCurrent(Stride.Particles.Particle@,System.Int32@,System.Int32@)">
            <summary>
            Removes the current particle
            </summary>
            <param name="particle">Reference to the particle being removed</param>
            <param name="oldIndex">Reference to the old current index so we can reposition it to point before the particle</param>
            <param name="indexMax">Maximum index value for this pool</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.RecalculateFieldsArrays">
            <summary>
            Recalculates the fields' offsets and strides. The methods are different for SoA and AoS policies
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticlePool.AddField(Stride.Particles.ParticleFieldDescription)">
            <summary>
            Adds a particle field to this pool with the specified description, or gets an existing one
            </summary>
            <param name="fieldDesc">Description of the field</param>
            <returns>The newly added or already existing field</returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.ReallocateForFieldAdded(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Reallocate the particles to a new memory block due to a newly added field
            </summary>
            <param name="oldPool">Old memory block</param>
            <param name="oldCapacity">Old capacity (maximum particle count) of the block</param>
            <param name="oldSize">Old size of a single particle</param>
            <param name="newPool">New memory block</param>
            <param name="newCapacity">New capacity (maximum particle count) of the block</param>
            <param name="newSize">New size of a single particle</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.ReallocateForCapacityChanged(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Reallocate the particles to a new memory block due to a change in the pool's capacity
            </summary>
            <param name="oldPool">Old memory block</param>
            <param name="oldCapacity">Old capacity (maximum particle count) of the block</param>
            <param name="oldSize">Old size of a single particle</param>
            <param name="newPool">New memory block</param>
            <param name="newCapacity">New capacity (maximum particle count) of the block</param>
            <param name="newSize">New size of a single particle</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.RemoveField(Stride.Particles.ParticleFieldDescription)">
            <summary>
            Removes a particle field from this pool with the specified description, or gets an existing one
            </summary>
            <param name="fieldDesc">Description of the field</param>
            <returns><c>true</c> if the field was successfully removed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.ReallocateForFieldRemoved(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Reallocate the particles to a new memory block due to a deleted field
            </summary>
            <param name="oldPool">Old memory block</param>
            <param name="oldCapacity">Old capacity (maximum particle count) of the block</param>
            <param name="oldSize">Old size of a single particle</param>
            <param name="newPool">New memory block</param>
            <param name="newCapacity">New capacity (maximum particle count) of the block</param>
            <param name="newSize">New size of a single particle</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.GetField``1(Stride.Particles.ParticleFieldDescription{``0})">
            <summary>
            Unsafe method for getting a <see cref="T:Stride.Particles.ParticleFieldAccessor"/>.
            If the field doesn't exist an invalid accessor is returned to the user.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fieldDesc"></param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.TryGetField``1(Stride.Particles.ParticleFieldDescription{``0},Stride.Particles.ParticleFieldAccessor{``0}@)">
            <summary>
            Gets the particle field with the specified description if the field exists in this pool
            </summary>
            <typeparam name="T">Type data for the field</typeparam>
            <param name="fieldDesc">Field's decription</param>
            <param name="accessor">Accessor for the field</param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.FieldExists(Stride.Particles.ParticleFieldDescription,System.Boolean)">
            <summary>
            Polls if a filed with this description exists in the pool and optionally forces creation of a new field
            </summary>
            <param name="fieldDesc">Description of the field</param>
            <param name="forceCreate">Force the creation of non-existing fields if <c>true</c></param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.GetEnumerator">
            <summary>
            Returns an <see cref="T:Stride.Particles.ParticlePool.Enumerator"/> to the particles in this <see cref="T:Stride.Particles.ParticlePool"/>
            In case of <see cref="F:Stride.Particles.ParticlePool.ListPolicy.Ring"/> dead particles are returned too, so the calling entity should handle such cases.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ParticlePool.Enumerator.#ctor(Stride.Particles.ParticlePool)">
            <summary>
            Creates an enumarator which iterates over all particles (living and dead) in the particle pool.
            </summary>
            <param name="particlePool">Particle pool to iterate</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.Enumerator.#ctor(Stride.Particles.ParticlePool,System.Int32,System.Int32)">
            <summary>
            <see cref="T:Stride.Particles.ParticlePool.Enumerator"/> to the particles in this <see cref="T:Stride.Particles.ParticlePool"/>
            </summary>
            <param name="particlePool">Particle pool to iterate</param>
            <param name="idxFrom">First valid particle index</param>
            <param name="idxTo">Last valid particle index</param>
        </member>
        <member name="M:Stride.Particles.ParticlePool.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ParticlePool.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ParticlePool.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ParticlePool.Enumerator.RemoveCurrent(Stride.Particles.Particle@)">
            <summary>
            Removes the current particle. A reference to the particle is required so that the addressing can be updated and prevent illegal access.
            </summary>
            <param name="particle">Reference to the particle being removed</param>
        </member>
        <member name="P:Stride.Particles.ParticlePool.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.ParticlePool.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ParticlePoolFieldsList.GetField``1(Stride.Particles.ParticleFieldDescription{``0})">
            <summary>
            Returns a particle field accessor for the contained <see cref="T:Stride.Particles.ParticlePool"/>
            </summary>
            <typeparam name="T">Type data for the field</typeparam>
            <param name="fieldDesc">The field description</param>
            <returns></returns>
        </member>
        <member name="F:Stride.Particles.RandomOffset.Lifetime">
            <summary>
            Lifetime offset should always be 0 so that it can easily be retrieved from the random seed.
            </summary>
        </member>
        <member name="F:Stride.Particles.RandomOffset.Offset1A">
            <summary>
            Random seed offset used for coupling 1-dimensional random values
            </summary>
        </member>
        <member name="F:Stride.Particles.RandomOffset.Offset2A">
            <summary>
            Random seed offset used for coupling 2-dimensional random values
            </summary>
        </member>
        <member name="F:Stride.Particles.RandomOffset.Offset3A">
            <summary>
            Random seed offset used for coupling 3-dimensional random values
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleSystem.timeout">
            <summary>
            If positive, it indicates how much remaining time there is before the system calls Stop()
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleSystem.Enabled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Stride.Particles.ParticleSystem"/> is enabled.
            </summary>
            <value>
              <c>true</c> if enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.ToWorldSpace(Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,Stride.Core.Mathematics.Vector3@)">
            <summary>
            Fixes local space location back to world space location. Used for debug drawing.
            </summary>
            <param name="translation">The locator's translation</param>
            <param name="rotation">The locator's quaternion rotation</param>
            <param name="scale">The locator's non-uniform scaling</param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.TryGetDebugDrawShape(Stride.Particles.DebugDraw.DebugDrawShape@,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,Stride.Core.Mathematics.Vector3@)">
            <summary>
            Tries to acquire and draw a debug shape for better feedback and visualization.
            </summary>
            <param name="debugDrawShape">The type of the debug shape (sphere, cone, etc.)</param>
            <param name="translation">The shape's translation</param>
            <param name="rotation">The shape's rotation</param>
            <param name="scale">The shape's non-uniform scaling</param>
            <returns><c>true</c> if debug shape can be displayed</returns>
        </member>
        <member name="P:Stride.Particles.ParticleSystem.Settings">
            <summary>
            Settings class which contains miscellaneous settings for the particle system
            </summary>
            <userdoc>
            Miscellaneous settings for the particle system. These settings are intended to be shared and are set during authoring of the particle system
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ParticleSystem.BoundingShape">
            <summary>
            AABB of this Particle System
            </summary>
            <userdoc>
            AABB (Axis-Aligned Bounding Box) used for fast culling and optimizations. Can be specified by the user. Leave it Null to disable culling.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.GetAABB">
            <summary>
            Gets the current AABB of the <see cref="T:Stride.Particles.ParticleSystem"/>
            </summary>
        </member>
        <member name="P:Stride.Particles.ParticleSystem.Emitters">
            <summary>
            List of Emitters in this <see cref="T:Stride.Particles.ParticleSystem"/>. Each Emitter has a separate <see cref="T:Stride.Particles.ParticlePool"/> (group) of Particles in it
            </summary>
            <userdoc>
            List of emitters in this particle system. Each Emitter has a separate particle pool (group) of particles in it
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleSystem.Translation">
            <summary>
            Translation of the ParticleSystem. Usually inherited directly from the ParticleSystemComponent or can be directly set.
            </summary>
            <userdoc>
            Translation of the ParticleSystem. Usually inherited directly from the ParticleSystemComponent or can be directly set.
            </userdoc>
        </member>
        <member name="F:Stride.Particles.ParticleSystem.Rotation">
            <summary>
            Rotation of the ParticleSystem, expressed as a quaternion rotation. Usually inherited directly from the ParticleSystemComponent or can be directly set.
            </summary>
            <userdoc>
            Rotation of the ParticleSystem, expressed as a quaternion rotation. Usually inherited directly from the ParticleSystemComponent or can be directly set.
            </userdoc>
        </member>
        <member name="F:Stride.Particles.ParticleSystem.UniformScale">
            <summary>
            Scale of the ParticleSystem. Only uniform scale is supported. Usually inherited directly from the ParticleSystemComponent or can be directly set.
            </summary>
            <userdoc>
            Scale of the ParticleSystem. Only uniform scale is supported. Usually inherited directly from the ParticleSystemComponent or can be directly set.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.InvalidateRelations">
            <summary>
            Invalidates relation of this emitter to any other emitters that might be referenced
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.Update(System.Single)">
            <summary>
            Updates the particles
            </summary>
            <param name="dt">Delta time - time, in seconds, elapsed since the last Update call to this particle system</param>
            <userdoc>
            Updates the particle system and all particles contained within. Delta time is the time, in seconds, which has passed since the last Update call.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.ResetSimulation">
            <summary>
            Resets the particle system, resetting all values to their initial state
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleSystem.isPaused">
            <summary>
            isPaused shows if the simulation progresses by delta time every frame or no
            </summary>
        </member>
        <member name="F:Stride.Particles.ParticleSystem.hasStarted">
            <summary>
            hasStarted shows if the simulation has started yet or no
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.Pause">
            <summary>
            Pauses the particle system simulation
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.Play">
            <summary>
            Use to both start a new simulation or continue a paused one
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.Stop">
            <summary>
            Stops the particle simulation by resetting it to its initial state and pausing it
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.Timeout(System.Single)">
            <summary>
            Disables emission of new particles and sets a time limit on the system. After the time expires, the system stops.
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.StopEmitters">
            <summary>
            Use to stop emitting new particles, but continue updating existing ones
            </summary>
        </member>
        <member name="M:Stride.Particles.ParticleSystem.GetEmitterByName(System.String)">
            <summary>
            Gets the first emitter with matching name which is contained in this <see cref="T:Stride.Particles.ParticleSystem"/>
            </summary>
            <param name="name">Name of the emitter. Some emitters might not have a name and cannot be referenced</param>
            <returns><see cref="T:Stride.Particles.ParticleEmitter"/> with the same <see cref="P:Stride.Particles.ParticleEmitter.EmitterName"/> or <c>null</c> if not found</returns>
        </member>
        <member name="P:Stride.Particles.ParticleSystemSettings.WarmupTime">
            <summary>
            Warm-up time is the amount of time the system should spend in the background pre-simulation the first time it is started
            </summary>
            <userdoc>
            Warm-up time is the amount of time the system should spend in the background pre-simulation the first time it is started (warming up). So when it is started it will appear as if it has been running for some time already
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Rendering.ParticleUtilitiesPerView">
            <summary>
            Should be identical to the cbuffer PerView in ParticleUtilities.sdsl
            </summary>
        </member>
        <member name="T:Stride.Particles.Rendering.ParticleEmitterRenderFeature">
            <summary>
            Renders <see cref="T:Stride.Particles.Rendering.RenderParticleEmitter"/>.
            </summary>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.InitializeCore">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.Extract">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.PrepareEffectPermutationsImpl(Stride.Rendering.RenderDrawContext)">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.Prepare(Stride.Rendering.RenderDrawContext)">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.BuildParticleBuffers(Stride.Rendering.RenderDrawContext)">
            <summary>
            Builds the shared vertex and index buffers used by the particle systems
            </summary>
            <param name="renderDrawContext"><see cref="T:Stride.Rendering.RenderDrawContext"/> to access the command list and the graphics context</param>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.ProcessPipelineState(Stride.Rendering.RenderContext,Stride.Rendering.RenderNodeReference,Stride.Rendering.RenderNode@,Stride.Rendering.RenderObject,Stride.Graphics.PipelineStateDescription)">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.Draw(Stride.Rendering.RenderDrawContext,Stride.Rendering.RenderView,Stride.Rendering.RenderViewStage,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleEmitterRenderFeature.Flush(Stride.Rendering.RenderDrawContext)">
            <inheritdoc/>
        </member>
        <member name="T:Stride.Particles.Rendering.ParticleSystemRenderProcessor">
            <summary>
            The processor in charge of updating and drawing the entities having sprite components.
            </summary>
        </member>
        <member name="M:Stride.Particles.Rendering.ParticleSystemRenderProcessor.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Stride.Particles.Rendering.ParticleSystemRenderProcessor"/> class.
            </summary>
        </member>
        <member name="T:Stride.Particles.Rendering.RenderParticleEmitter">
            <summary>
            Defines a particle emitter to render.
            </summary>
        </member>
        <member name="T:Stride.Particles.Rendering.RenderParticleSystem">
            <summary>
            Defines a particle system to render.
            </summary>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.EdgePolicy">
            <summary>
            Specifies if the trail lies on one edge on the axis or is the axis in its center.
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.EdgePolicy.Edge">
            <summary>
            The line between the control points will be used as an edge for the trail or ribbon
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.EdgePolicy.Center">
            <summary>
            The line between the control points will be used as a central axis for the trail or ribbon
            </summary>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilder">
            <summary>
            The <see cref="T:Stride.Particles.ShapeBuilders.ShapeBuilder"/> base class is responsible for generating shapes (procedural mesh) ready for rendering from the particle data
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilder.QuadsPerParticle">
            <summary>
            Returns the number of quads required per particle to draw all particles. Assuming 1 Quad = 4 Vertices = 6 Indices
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilder.VertexLayoutHasChanged">
            <summary>
            Indicates that the required vertex layout has changed and <see cref="M:Stride.Particles.ShapeBuilders.ShapeBuilder.UpdateVertexBuilder(Stride.Particles.VertexLayouts.ParticleVertexBuilder)"/> should be called
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilder.BuildVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,System.Single,Stride.Particles.Sorters.ParticleList@,Stride.Core.Mathematics.Matrix@)">
            <summary>
            Builds the actual vertex buffer for the current frame using the particle data
            </summary>
            <param name="bufferState">Target particle buffer state, used to populate the assigned vertex buffer</param>
            <param name="invViewX">Unit vector X (right) in camera space, extracted from the inverse view matrix</param>
            <param name="invViewY">Unit vector Y (up) in camera space, extracted from the inverse view matrix</param>
            <param name="spaceTranslation">Translation of the target draw space in regard to the particle data (world or local)</param>
            <param name="spaceRotation">Rotation of the target draw space in regard to the particle data (world or local)</param>
            <param name="spaceScale">Uniform scale of the target draw space in regard to the particle data (world or local)</param>
            <param name="sorter">Particle enumerator which can be iterated and returns sported particles</param>
            <param name="viewProj">The View-Projection matrix which is used for some shape builders</param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilder.PrepareVertexLayout(Stride.Particles.ParticlePoolFieldsList)">
            <summary>
            Check if ParticleVertexElements should be changed and set HasVertexLayoutChanged = true; if they do
            </summary>
            <param name="fieldsList">A container for the <see cref="T:Stride.Particles.ParticlePool"/> which can poll if a certain field exists as an attribute</param>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilder.UpdateVertexBuilder(Stride.Particles.VertexLayouts.ParticleVertexBuilder)">
            <summary>
            Should be invoked if the <see cref="P:Stride.Particles.ShapeBuilders.ShapeBuilder.VertexLayoutHasChanged"/> was <c>true</c> so that new layout fields can be added to the buffer builder
            </summary>
            <param name="vertexBuilder">Target vertex buffer stream builder which will be used for the current frame</param>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilder.SetRequiredQuads(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the required quads per particle and number of particles so that a sufficiently big buffer can be allocated
            </summary>
            <param name="quadsPerParticle">Required quads per particle, assuming 1 quad = 4 vertices = 6 indices</param>
            <param name="livingParticles">Number of living particles this frame</param>
            <param name="totalParticles">Number of total number of possible particles for the parent emitter</param>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilder.Circumcenter(Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Vector3@)">
            <summary>
            Finds the circumcenter coordinates for triangle ABC
            </summary>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderBillboard">
            <summary>
            Shape builder which builds each particle as a camera-facing quad
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderBillboard.QuadsPerParticle">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderBillboard.SamplerRotation">
            <summary>
            Additive animation for the particle rotation. If present, particle's own rotation will be added to the sampled curve value
            </summary>
            <userdoc>
            Additive animation for the particle rotation. If present, particle's own rotation will be added to the sampled curve value
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderBillboard.PreUpdate">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderBillboard.BuildVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,System.Single,Stride.Particles.Sorters.ParticleList@,Stride.Core.Mathematics.Matrix@)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderBillboard.GetParticleRotation(Stride.Particles.Particle,Stride.Particles.ParticleFieldAccessor{System.Single},Stride.Particles.ParticleFieldAccessor{System.Single})">
            <summary>
            Gets the combined rotation for the particle, adding its field value (if any) to its sampled value from the curve
            </summary>
            <param name="particle">Target particle</param>
            <param name="rotationField">Rotation field accessor</param>
            <param name="lifeField">Normalized particle life for sampling</param>
            <returns>Screenspace rotation in radians, positive is clockwise</returns>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderCommon">
            <summary>
            The common shape builder provides additive animation for the particle's position and size fields,
             assuming that all derived shape builders will have position and size fields
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderCommon.PreUpdate">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderCommon.SamplerPosition">
            <summary>
            Additive animation for the particle position. If present, particle's own position will be added to the sampled curve value
            </summary>
            <userdoc>
            Additive animation for the particle position. If present, particle's own position will be added to the sampled curve value
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderCommon.SamplerSize">
            <summary>
            Additive animation for the particle size. If present, particle's own size will be multiplied with the sampled curve value
            </summary>
            <userdoc>
            Additive animation for the particle size. If present, particle's own size will be multiplied with the sampled curve value
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderCommon.GetParticlePosition(Stride.Particles.Particle,Stride.Particles.ParticleFieldAccessor{Stride.Core.Mathematics.Vector3},Stride.Particles.ParticleFieldAccessor{System.Single})">
            <summary>
            Gets the combined position for the particle, adding its field value (if any) to its sampled value from the curve
            </summary>
            <param name="particle"></param>
            <param name="positionField"></param>
            <param name="lifeField">Normalized life for sampling</param>
            <returns>Particle's current 3D position</returns>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderCommon.GetParticleSize(Stride.Particles.Particle,Stride.Particles.ParticleFieldAccessor{System.Single},Stride.Particles.ParticleFieldAccessor{System.Single})">
            <summary>
            Gets the combined size for the particle, adding its field value (if any) to its sampled value from the curve
            </summary>
            <param name="particle">Target particle</param>
            <param name="sizeField">Size field accessor</param>
            <param name="lifeField">Normalized life for sampling</param>
            <returns>Particle's current uniform size</returns>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderHexagon">
            <summary>
            Shape builder which builds each particle as a camera-facing hexagon
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderHexagon.QuadsPerParticle">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderHexagon.SamplerRotation">
            <summary>
            Additive animation for the particle rotation. If present, particle's own rotation will be added to the sampled curve value
            </summary>
            <userdoc>
            Additive animation for the particle rotation. If present, particle's own rotation will be added to the sampled curve value
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderHexagon.PreUpdate">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderHexagon.BuildVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,System.Single,Stride.Particles.Sorters.ParticleList@,Stride.Core.Mathematics.Matrix@)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderHexagon.GetParticleRotation(Stride.Particles.Particle,Stride.Particles.ParticleFieldAccessor{System.Single},Stride.Particles.ParticleFieldAccessor{System.Single})">
            <summary>
            Gets the combined rotation for the particle, adding its field value (if any) to its sampled value from the curve
            </summary>
            <param name="particle">Target particle</param>
            <param name="rotationField">Rotation field accessor</param>
            <param name="lifeField">Normalized particle life for sampling</param>
            <returns>Screen space rotation in radians, positive is clockwise</returns>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderOrientedQuad">
            <summary>
            Shape builder which builds each particle as a non-uniform quad oriented along an axis
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderOrientedQuad.ScaleLength">
            <summary>
            If <c>true</c>, length will scale with particle size
            </summary>
            <userdoc>
            If true, length will scale with particle size
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderOrientedQuad.LengthFactor">
            <summary>
            Length will be modified with this factor
            </summary>
            <userdoc>
            Length will be modified with this factor
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderOrientedQuad.QuadsPerParticle">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderOrientedQuad.BuildVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,System.Single,Stride.Particles.Sorters.ParticleList@,Stride.Core.Mathematics.Matrix@)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderQuad">
            <summary>
            Shape builder which builds each particle as a up-facing quad, further rotated by the particle's rotation in 3d space
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderQuad.QuadsPerParticle">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderQuad.SamplerRotation">
            <summary>
            Additive animation for the particle rotation. If present, particle's own rotation will be added to the sampled curve value
            </summary>
            <userdoc>
            Additive animation for the particle rotation. If present, particle's own rotation will be added to the sampled curve value
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderQuad.PreUpdate">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderQuad.BuildVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,System.Single,Stride.Particles.Sorters.ParticleList@,Stride.Core.Mathematics.Matrix@)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderQuad.GetParticleRotation(Stride.Particles.Particle,Stride.Particles.ParticleFieldAccessor{Stride.Core.Mathematics.Quaternion},Stride.Particles.ParticleFieldAccessor{System.Single})">
            <summary>
            Gets the combined rotation for the particle, adding its field value (if any) to its sampled value from the curve
            </summary>
            <param name="particle">Target particle</param>
            <param name="rotationField">Rotation field accessor</param>
            <param name="lifeField">Normalized particle life for sampling</param>
            <returns>Quaternion rotation of the quad particle, assuming flat horizontal square at neutral rotation</returns>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon">
            <summary>
            Shape builder which builds all particles as a ribbon, connecting adjacent particles with camera-facing quads
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.SmoothingPolicy">
            <summary>
            Smoothing provides the option to additionally smooth the ribbon, enhancing visual quality for sharp angles
            </summary>
            <userdoc>
            Smoothing provides the option to additionally smooth the ribbon, enhancing visual quality for sharp angles
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Segments">
            <summary>
            If the ribbon is smotthed, how many segments should be used between each two particles
            </summary>
            <userdoc>
            If the ribbon is smotthed, how many segments should be used between each two particles
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.TextureCoordinatePolicy">
            <summary>
            Specifies how texture coordinates for the ribbons should be built
            </summary>
            <userdoc>
            Specifies how texture coordinates for the ribbons should be built
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.TexCoordsFactor">
            <summary>
            The factor (coefficient) for length to use when building texture coordinates
            </summary>
            <userdoc>
            The factor (coefficient) for length to use when building texture coordinates
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.UVRotate">
            <summary>
            Texture coordinates flip and rotate policy
            </summary>
            <userdoc>
            Texture coordinates flip and rotate policy
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.QuadsPerParticle">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.SetRequiredQuads(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.BuildVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,System.Single,Stride.Particles.Sorters.ParticleList@,Stride.Core.Mathematics.Matrix@)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer">
            <summary>
            The <see cref="T:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer"/> takes a list of points and creates a ribbon (connected quads), adjusting its texture coordinates accordingly
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer.RibbonSplit">
            <summary>
            Splits (cuts) the ribbon without restarting or rebuilding the vertex buffer
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer.AddParticle(Stride.Core.Mathematics.Vector3@,System.Single)">
            <summary>
            Adds a new particle position and size to the point string
            </summary>
            <param name="position"></param>
            <param name="size"></param>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer.GetWidthVector(System.Single,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Vector3@)">
            <summary>
            Returns the half width vector at the sampled position along the ribbon
            </summary>
            <param name="particleSize">Particle's size, sampled from the size field</param>
            <param name="invViewZ">Unit vector Z in clip space, pointing towards the camera</param>
            <param name="axis0">Central axis between the particle and the previous point along the ribbon</param>
            <param name="axis1">Central axis between the particle and the next point along the ribbon</param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer.ExpandVertices_Circular">
            <summary>
            Advanced interpolation, drawing the vertices in a circular arc between two adjacent control points
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer.ExpandVertices_CatmullRom">
            <summary>
            Simple interpolation using Catmull-Rom
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderRibbon.Ribbonizer.Ribbonize(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,System.Int32,Stride.Core.Mathematics.Matrix@)">
            <summary>
            Constructs the ribbon by outputting vertex stream based on the positions and sizes specified previously
            </summary>
            <param name="bufferState">Target <see cref="T:Stride.Particles.VertexLayouts.ParticleBufferState"/></param> to use
            <param name="invViewX">Unit vector X in clip space as calculated from the inverse view matrix</param>
            <param name="invViewY">Unit vector Y in clip space as calculated from the inverse view matrix</param>
            <param name="quadsPerParticle">The required number of quads per each particle</param>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderTrail">
            <summary>
            Shape builder which builds all particles as a trail, connecting adjacent particles in a ribbon defined by a fixed 3d axis
            </summary>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.SmoothingPolicy">
            <summary>
            Smoothing provides the option to additionally smooth the ribbon, enhancing visual quality for sharp angles
            </summary>
            <userdoc>
            Smoothing provides the option to additionally smooth the ribbon, enhancing visual quality for sharp angles
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Segments">
            <summary>
            If the ribbon is smotthed, how many segments should be used between each two particles
            </summary>
            <userdoc>
            If the ribbon is smotthed, how many segments should be used between each two particles
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.EdgePolicy">
            <summary>
            Should the axis of control point be treated as the trail's edge or the trail's center
            </summary>
            <userdoc>
            Should the axis of control point be treated as the trail's edge or the trail's center
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.TextureCoordinatePolicy">
            <summary>
            Specifies how texture coordinates for the ribbons should be built
            </summary>
            <userdoc>
            Specifies how texture coordinates for the ribbons should be built
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.TexCoordsFactor">
            <summary>
            The factor (coefficient) for length to use when building texture coordinates
            </summary>
            <userdoc>
            The factor (coefficient) for length to use when building texture coordinates
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.UVRotate">
            <summary>
            Texture coordinates flip and rotate policy
            </summary>
            <userdoc>
            Texture coordinates flip and rotate policy
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.QuadsPerParticle">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.SetRequiredQuads(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.BuildVertexBuffer(Stride.Particles.VertexLayouts.ParticleBufferState@,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,System.Single,Stride.Particles.Sorters.ParticleList@,Stride.Core.Mathematics.Matrix@)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Ribbonizer">
            <summary>
            The <see cref="T:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Ribbonizer"/> takes a list of points and creates a ribbon (connected quads), adjusting its texture coordinates accordingly
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Ribbonizer.RibbonSplit">
            <summary>
            Splits (cuts) the trail without restarting or rebuilding the vertex buffer
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Ribbonizer.AddParticle(Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Vector3@)">
            <summary>
            Adds a new particle position and size to the point string
            </summary>
            <param name="position">Position of the control point</param>
            <param name="direction">Direction or offset from the control point</param>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Ribbonizer.ExpandVertices_Circular">
            <summary>
            Advanced interpolation, drawing the vertices in a circular arc between two adjacent control points
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Ribbonizer.ExpandVertices_CatmullRom">
            <summary>
            Simple interpolation using Catmull-Rom
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.ShapeBuilderTrail.Ribbonizer.Ribbonize(Stride.Particles.VertexLayouts.ParticleBufferState@,System.Int32)">
            <summary>
            Constructs the ribbon by outputting vertex stream based on the positions and sizes specified previously
            </summary>
            <param name="vtxBuilder">Target <see cref="T:Stride.Particles.VertexLayouts.ParticleVertexBuilder"/></param> to use
            <param name="quadsPerParticle">The required number of quads per each particle</param>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.SmoothingPolicy">
            <summary>
            Specifies if the ribbon should be additionally smoothed or rendered as is.
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.SmoothingPolicy.None">
            <summary>
            Ribbons only use control points and edges are hard. Good for straight lines
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.SmoothingPolicy.Fast">
            <summary>
            Smoothing using Catmull-Rom interpolation. Generally looks good
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.SmoothingPolicy.Best">
            <summary>
            Smoothing based on circumcircles generated around every three adjacent points. Best suited for rapid, circular motions
            </summary>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.TextureCoordinatePolicy">
            <summary>
            Specifies how texture coordinates should be assigned to the ribbonized mesh.
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.TextureCoordinatePolicy.AsIs">
            <summary>
            <see cref="F:Stride.Particles.ShapeBuilders.TextureCoordinatePolicy.AsIs"/> will assign a (0, 0, 1, 1) quad to each segment along the ribbon.
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.TextureCoordinatePolicy.Stretched">
            <summary>
            <see cref="F:Stride.Particles.ShapeBuilders.TextureCoordinatePolicy.Stretched"/> will assign a (0, 0, 1, X) quad stretched over the entire ribbon, where X is user-defined.
            </summary>
        </member>
        <member name="F:Stride.Particles.ShapeBuilders.TextureCoordinatePolicy.DistanceBased">
            <summary>
            <see cref="F:Stride.Particles.ShapeBuilders.TextureCoordinatePolicy.DistanceBased"/> will assign a (0, 0, 1, Length) quad stretched over the entire ribbon, where Length is the actual length of the ribbon.
            </summary>
        </member>
        <member name="T:Stride.Particles.ShapeBuilders.Tools.UVRotate">
            <summary>
            Struct used to rotate and/or flip texture coordinates
            </summary>
            <userdoc>
            Option used to rotate and/or flip texture coordinates
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.Tools.UVRotate.FlipX">
            <summary>
            If <c>True</c>, the texture coordinates will be flipped horizontally prior to texture sampling.
            </summary>
            <userdoc>
            If <c>True</c>, the texture coordinates will be flipped horizontally prior to texture sampling.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.Tools.UVRotate.FlipY">
            <summary>
            If <c>True</c>, the texture coordinates will be flipped vertically prior to texture sampling.
            </summary>
            <userdoc>
            If <c>True</c>, the texture coordinates will be flipped vertically prior to texture sampling. 
            </userdoc>
        </member>
        <member name="P:Stride.Particles.ShapeBuilders.Tools.UVRotate.UVClockwise">
            <summary>
            If <c>True</c>, the texture coordinates will be rotated clockwise by the specified angle prior to texture sampling.
            </summary>
            <userdoc>
            If <c>True</c>, the texture coordinates will be rotated clockwise by the specified angle prior to texture sampling.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.Tools.UVRotate.ApplyChanges">
            <summary>
            Precalculate the flags required for sampling and swapping texture coordinates
            </summary>
        </member>
        <member name="M:Stride.Particles.ShapeBuilders.Tools.UVRotate.GetCoords(Stride.Core.Mathematics.Vector2)">
            <summary>
            Returns the rotated texture coordinates for base input texture coordinates
            </summary>
            <param name="inVector">Base texture coordinates</param>
            <returns>Rotated and flipped coordinates</returns>
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleList.GetField``1(Stride.Particles.ParticleFieldDescription{``0})">
            <summary>
            Returns a particle field accessor for the contained <see cref="T:Stride.Particles.ParticlePool"/>
            </summary>
            <typeparam name="T">Type data for the field</typeparam>
            <param name="fieldDesc">The field description</param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleList.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleList.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleList.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Sorters.ParticleSorterAge">
            <summary>
            Sorts the particles by descending order of their remaining Life
            </summary>
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleSorterAge.FreeSortedList(Stride.Particles.Sorters.ParticleList@)">
            <summary>
            In case an array was used it must be freed back to the pool
            </summary>
            <param name="sortedList">Reference to the <see cref="T:Stride.Particles.Sorters.ParticleList"/> to be freed</param>
        </member>
        <member name="T:Stride.Particles.Sorters.ParticleSorterCustom`1">
            <summary>
            The custom sorter uses a user-defined method for generating sort index from a user-defined field
            </summary>
        </member>
        <member name="M:Stride.Particles.Sorters.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Sorters.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Sorters.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Sorters.ParticleSorterDefault">
            <summary>
            The default sorter doesn not sort the particles, but only passes them directly to the renderer
            </summary>
        </member>
        <member name="F:Stride.Particles.Sorters.ParticleSorterDefault.ParticlePool">
            <summary>
            Target <see cref="F:Stride.Particles.Sorters.ParticleSorterDefault.ParticlePool"/> to iterate and sort
            </summary>
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleSorterDefault.FreeSortedList(Stride.Particles.Sorters.ParticleList@)">
            <summary>
            The default sorter does not allocate any resources so there is nothing to free
            </summary>
            <param name="sortedList">Reference to the <see cref="T:Stride.Particles.Sorters.ParticleList"/> to be freed</param>
        </member>
        <member name="T:Stride.Particles.Sorters.ParticleSorterDepth">
            <summary>
            Sorts the particles by ascending order of their Depth (position on the camera's Z axis)
            </summary>
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleSorterDepth.FreeSortedList(Stride.Particles.Sorters.ParticleList@)">
            <summary>
            In case an array was used it must be freed back to the pool
            </summary>
            <param name="sortedList">Reference to the <see cref="T:Stride.Particles.Sorters.ParticleList"/> to be freed</param>
        </member>
        <member name="T:Stride.Particles.Sorters.ParticleSorterOrder">
            <summary>
            Sorts the particles by ascending order of their Order attribute
            </summary>
        </member>
        <member name="M:Stride.Particles.Sorters.ParticleSorterOrder.FreeSortedList(Stride.Particles.Sorters.ParticleList@)">
            <summary>
            In case an array was used it must be freed back to the pool
            </summary>
            <param name="sortedList">Reference to the <see cref="T:Stride.Particles.Sorters.ParticleList"/> to be freed</param>
        </member>
        <member name="T:Stride.Particles.Spawners.ParentControlFlag">
            <summary>
            Some initializers require fine control between parent and child emitters. Use the control group to assign such meta-fields.
            </summary>
            <userdoc>
            Some initializers require fine control between parent and child emitters. Use the control group to assign such meta-fields.
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Spawners.ParentControlFlag.Group00">
            <summary>
            Use a meta-data control group with index 0
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.ParentControlFlag.Group01">
            <summary>
            Use a meta-data control group with index 1
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.ParentControlFlag.Group02">
            <summary>
            Use a meta-data control group with index 2
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.ParentControlFlag.Group03">
            <summary>
            Use a meta-data control group with index 3
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.ParentControlFlag.None">
            <summary>
            Do not use meta-data control groups
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerLoopCondition.Looping">
            <summary>
            Looping spawner will loop to the beginning of its Delay state when its Duration is over
            If there is no delay it's indistinguishable from LoopingNoDelay
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerLoopCondition.LoopingNoDelay">
            <summary>
            LoopingNoDelay spawner will loop to the beginning of its Active state when its Duration is over
                essentially skipping the Delay state after the first loop
            If there is no delay it's indistinguishable from Looping
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerLoopCondition.OneShot">
            <summary>
            OneShot particle spawners will not loop and will only be ative for a period of time equal to its Duration
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerState.Inactive">
            <summary>
            A spawner in Inactive state hasn't been updated yet. Upon constructing, the Spawner is Inactive,
                but can't return to this state anymore
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerState.Rest">
            <summary>
            A spawner starts in Rest state and stays in this state for as long as it is delayed.
            While in Rest state it doesn't emit particles and switches to Active state after the Rest state is over
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerState.Active">
            <summary>
            A spawner in Active state emits particles. After the Active state expires, the spawner can switch to
                Rest, Active or Dead state depending on its looping condition.
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerState.Dead">
            <summary>
            A spawner in Dead state is not emitting particles and likely not switching to Rest or Active anymore.
            </summary>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawner">
            <summary>
            <see cref="T:Stride.Particles.Spawners.ParticleSpawner"/> governs the rate at which new particles are emitted into the <see cref="T:Stride.Particles.ParticleEmitter"/>
            Multiple spawners with different triggering conditions can be part of the same <see cref="T:Stride.Particles.ParticleEmitter"/>
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.ParticleSpawner.Enabled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Stride.Particles.Spawners.ParticleSpawner"/> is enabled.
            </summary>
            <value>
              <c>true</c> if enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Stride.Particles.Spawners.ParticleSpawner.LoopCondition">
            <summary>
            Indicates if the spawner should loop, and if there is a delay every time it loops
            </summary>
            <userdoc>
            Indicates if the spawner should loop, and if there is a delay every time it loops
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Spawners.ParticleSpawner.Delay">
            <summary>
            The minimum and maximum time the spawner should wait before starting to emit particles
            </summary>
            <userdoc>
            The minimum and maximum time the spawner should wait before starting to emit particles
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Spawners.ParticleSpawner.Duration">
            <summary>
            The minimum and maximum duration the spawner will be active once it starts spawning particles
            </summary>
            <userdoc>
            The minimum and maximum duration the spawner will be active once it starts spawning particles
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.ResetSimulation">
            <summary>
            Restarts the spawner setting it to inactive state and elapsed time = 0
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.MarkAsDirty">
            <summary>
            Marking the spawner as dirty will notify the parent emitter that the maximum number of particles need to be recalculated
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.NextFloat">
            <summary>
            Gets a next random float value from the random seed
            </summary>
            <returns>Random float value in the range [0..1)</returns>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.SwitchToState(Stride.Particles.Spawners.SpawnerState)">
            <summary>
            Changes the spawners internal state (active, rest, etc.) to a new value.
            </summary>
            <param name="newState">The new state</param>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.GetUpdatedState(System.Single,Stride.Particles.ParticleEmitter)">
            <summary>
            Updates and gets the current internal state
            </summary>
            <param name="dt">Delta time in seconds since the last <see cref="M:Stride.Particles.Spawners.ParticleSpawner.GetUpdatedState(System.Single,Stride.Particles.ParticleEmitter)"/> was called</param>
            <param name="emitter">Parent <see cref="T:Stride.Particles.ParticleEmitter"/> for this spawner</param>
            <returns></returns>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.SpawnNew(System.Single,Stride.Particles.ParticleEmitter)">
            <summary>
            This method will be called form the emitter when it needs to poll how many particles to spawn (usually once per frame)
            </summary>
            <param name="dt">Time it has past since the last update (in seconds)</param>
            <param name="emitter">Parent emitter in which new particles should be emitter</param>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.GetMaxParticlesPerSecond">
            <summary>
            Get the maximum number of particles this spawner can emit in one second
            </summary>
            <returns>Peak particles per second</returns>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.InvalidateRelations">
            <summary>
            Invalidates relation of this emitter to any other emitters that might be referenced
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawner.NotifyStateSwitch(Stride.Particles.Spawners.SpawnerState)">
            <summary>
            Will be called when the state changes. Override if you need to set/reset variables based on state changes
            </summary>
            <param name="newState">The new state</param>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawnTriggerBirth">
            <summary>
            <see cref="T:Stride.Particles.Spawners.ParticleSpawnTriggerBirth"/> triggers when the parent particle is first spawned
            </summary>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawnTrigger">
            <summary>
            <see cref="T:Stride.Particles.Spawners.ParticleSpawnTrigger"/> governs the condition under which particle emission is triggered for spawners like <see cref="T:Stride.Particles.Spawners.SpawnerFromParent"/>
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawnTrigger.PrepareFromPool(Stride.Particles.ParticlePool)">
            <summary>
            Prepares fields accessors before the 
            </summary>
            <param name="pool"></param>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawnTrigger.HasTriggered(Stride.Particles.Particle)">
            <summary>
            For positive values, shows if the condition was met and how much is the magnitude
            </summary>
            <param name="parentParticle">Parent particle which attributes are used for testing</param>
            <returns>0f if it hasn't triggered, positive value otherwise, which also indicates the magnitude of the trigger</returns>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawnTrigger.AddRequiredParentFields(Stride.Particles.ParticleEmitter)">
            <summary>
            Override to add the required fields to the parent emitter
            </summary>
            <param name="parentEmitter">Parent emitter to which required fields should be added</param>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawnTrigger.RemoveRequiredParentFields(Stride.Particles.ParticleEmitter)">
            <summary>
            Override to remove the required fields from the parent emitter
            </summary>
            <param name="parentEmitter">Parent emitter from which required fields should be removed</param>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawnTrigger`1">
            <inheritdoc/>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawnTriggerCollision">
            <summary>
            <see cref="T:Stride.Particles.Spawners.ParticleSpawnTriggerCollision"/> triggers when the parent particle collides with a surface
            </summary>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawnTriggerDeath">
            <summary>
            <see cref="T:Stride.Particles.Spawners.ParticleSpawnTriggerDeath"/> triggers when the parent particle dies
            </summary>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawnTriggerDistance">
            <summary>
            <see cref="T:Stride.Particles.Spawners.ParticleSpawnTriggerDistance"/> triggers when the parent particle tarvels beyond set distance
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawnTriggerDistance.AddRequiredParentFields(Stride.Particles.ParticleEmitter)">
            <inheritdoc/>
        </member>
        <member name="M:Stride.Particles.Spawners.ParticleSpawnTriggerDistance.RemoveRequiredParentFields(Stride.Particles.ParticleEmitter)">
            <inheritdoc/>
        </member>
        <member name="T:Stride.Particles.Spawners.ParticleSpawnTriggerLifetime">
            <summary>
            <see cref="T:Stride.Particles.Spawners.ParticleSpawnTriggerLifetime"/> triggers when the parent particle's remaining lifetime is within the specified limit
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.ParticleSpawnTriggerLifetime.LifetimeLowerLimit">
            <summary>
            If the parent particle is younger than the lower limit, it won't spawn children. When the lower limit is higher than the upper limit the condition is reversed.
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.ParticleSpawnTriggerLifetime.LifetimeUpperLimit">
            <summary>
            If the parent particle is older than the upper limit, it won't spawn children. When the upper limit is smaller than the lower limit the condition is reversed.
            </summary>
        </member>
        <member name="T:Stride.Particles.Spawners.SpawnerBurst">
            <summary>
            A particle spawner which continuously spawns particles. Number of particles to be spawned is given in seconds.
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerBurst.SpawnCount">
            <summary>
            The amount of particles this spawner will emit in one burst when it activates
            </summary>
            <userdoc>
            The amount of particles this spawner will emit in one burst when it activates
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerBurst.GetMaxParticlesPerSecond">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerBurst.SpawnNew(System.Single,Stride.Particles.ParticleEmitter)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerBurst.NotifyStateSwitch(Stride.Particles.Spawners.SpawnerState)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Spawners.SpawnerFromDistance">
            <summary>
            A particle spawner which continuously spawns particles. Number of particles to be spawned is given in seconds.
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerFromDistance.SpawnCount">
            <summary>
            The amount of particles this spawner will emit over one second, every second
            </summary>
            <userdoc>
            The amount of particles this spawner will emit over one second, every second
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromDistance.GetMaxParticlesPerSecond">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromDistance.SpawnNew(System.Single,Stride.Particles.ParticleEmitter)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Spawners.SpawnerFromParent">
            <summary>
            A particle spawner which continuously spawns particles based on a condition set in a followed (parent) emitter
            </summary>
            <userdoc>
            A particle spawner which continuously spawns particles based on a condition set in a followed (parent) emitter
            </userdoc>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerFromParent.parentControlFlag">
            <summary>
            Some initializers require fine control between parent and child emitters. Use the control group to assign such meta-fields.
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerFromParent.particleSpawnTrigger">
            <summary>
            <see cref="P:Stride.Particles.Spawners.SpawnerFromParent.ParticleSpawnTrigger"/> provides a class which checks if the spawning condition has triggered
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerFromParent.Parent">
            <summary>
            Referenced parent emitter
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerFromParent.parentName">
            <summary>
            Referenced parent emitter's name
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerFromParent.isParentNameDirty">
            <summary>
            <c>true</c> is the parent's name has changed or the particle system has been invalidated
            </summary>
        </member>
        <member name="F:Stride.Particles.Spawners.SpawnerFromParent.spawnCount">
            <summary>
            Minimum and maximum number of particles to spawn every time the condition is met
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerFromParent.ParentName">
            <summary>
            Name by which to reference a followed (parent) emitter
            </summary>
            <userdoc>
            Name by which to reference a followed (parent) emitter
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerFromParent.ParentControlFlag">
            <summary>
            Some initializers require fine control between parent and child emitters. Use the control group to assign such meta-fields.
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromParent.RemoveControlGroup">
            <summary>
            Removes the old required control group field from the parent emitter's pool
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromParent.AddControlGroup">
            <summary>
            Adds the required control group field to the parent emitter's pool
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromParent.GetSpawnControlField">
            <summary>
            Gets a field accessor to the parent emitter's spawn control field, if it exists
            </summary>
            <returns></returns>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerFromParent.ParticleSpawnTrigger">
            <summary>
            <see cref="P:Stride.Particles.Spawners.SpawnerFromParent.ParticleSpawnTrigger"/> provides a class which checks if the spawning condition has triggered
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerFromParent.SpawnCount">
            <summary>
            The amount of particles this spawner will emit when the event is triggered
            </summary>
            <userdoc>
            The amount of particles this spawner will emit when the event is triggered
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromParent.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromParent.GetMaxParticlesPerSecond">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromParent.SpawnNew(System.Single,Stride.Particles.ParticleEmitter)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerFromParent.InvalidateRelations">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Spawners.SpawnerPerFrame">
            <summary>
            A particle spawner which continuously spawns particles. Number of particles to be spawned is given in seconds.
            </summary>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerPerFrame.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerPerFrame.SpawnCount">
            <summary>
            The amount of particles this spawner will emit each frame
            </summary>
            <userdoc>
            The amount of particles this spawner will emit each frame
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerPerFrame.Framerate">
            <summary>
            The maximum framerate you expect your game to achieve. It is only used for maximum particles estimation, not for actual spawning rate
            </summary>
            <userdoc>
            The maximum framerate you expect your game to achieve. It is only used for maximum particles estimation, not for actual spawning rate
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerPerFrame.GetMaxParticlesPerSecond">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerPerFrame.SpawnNew(System.Single,Stride.Particles.ParticleEmitter)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Spawners.SpawnerPerSecond">
            <summary>
            A particle spawner which continuously spawns particles. Number of particles to be spawned is given in seconds.
            </summary>
        </member>
        <member name="P:Stride.Particles.Spawners.SpawnerPerSecond.SpawnCount">
            <summary>
            The amount of particles this spawner will emit over one second, every second
            </summary>
            <userdoc>
            The amount of particles this spawner will emit over one second, every second
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerPerSecond.GetMaxParticlesPerSecond">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Spawners.SpawnerPerSecond.SpawnNew(System.Single,Stride.Particles.ParticleEmitter)">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Cube.HalfSideX">
            <summary>
            The maximum distance from the origin along the X axis. The X side is twice as big.
            </summary>
            <userdoc>
            The maximum distance from the origin along the X axis. The X side is twice as big.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Cube.HalfSideY">
            <summary>
            The maximum distance from the origin along the Y axis. The Y side is twice as big.
            </summary>
            <userdoc>
            The maximum distance from the origin along the Y axis. The Y side is twice as big.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Cube.HalfSideZ">
            <summary>
            The maximum distance from the origin along the Z axis. The Z side is twice as big.
            </summary>
            <userdoc>
            The maximum distance from the origin along the Z axis. The Z side is twice as big.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Cylinder.HalfHeight">
            <summary>
            The maximum distance from the origin along the Y axis. The height is twice as big.
            </summary>
            <userdoc>
            The maximum distance from the origin along the Y axis. The height is twice as big.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Cylinder.Radius">
            <summary>
            The maximum distance from the central axis.
            </summary>
            <userdoc>
            The maximum distance from the central axis.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.FieldFalloff.StrengthInside">
            <summary>
            The strength of the force in the center of the bounding shape.
            </summary>
            <userdoc>
            The strength of the force in the center of the bounding shape.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.FieldFalloff.FalloffStart">
            <summary>
            After this relative distance from the center, the force strength will start to change
            </summary>
            <userdoc>
            After this relative distance from the center, the force strength will start to change
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.FieldFalloff.StrengthOutside">
            <summary>
            The strength of the force outside the bounding shape.
            </summary>
            <userdoc>
            The strength of the force outside the bounding shape.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.FieldFalloff.FalloffEnd">
            <summary>
            After this relative distance from the center, the force strength will be equal to [Strength outside]
            </summary>
            <userdoc>
            After this relative distance from the center, the force strength will be equal to [Strength outside]
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Updaters.FieldShapes.FieldFalloff.GetStrength(System.Single)">
            <summary>
            Get interpolated strength based on relative distance from the center (lerp)
            </summary>
            <param name="inDistance"></param>
            <returns></returns>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Sphere.Radius">
            <summary>
            The maximum distance from the central point.
            </summary>
            <userdoc>
            The maximum distance from the central point.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Torus.BigRadius">
            <summary>
            Big radius of the torus
            </summary>
            <userdoc>
            Big radius of the torus (defines the circle around which the torus is positioned)
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.FieldShapes.Torus.SmallRadius">
            <summary>
            Small radius of the torus, given as a relative size to the big radius
            </summary>
            <userdoc>
            Small radius of the torus, given as a relative to the big radius (percentage between 0 and 1)
            </userdoc>
        </member>
        <member name="T:Stride.Particles.Updaters.UpdaterColorOverTime">
            <summary>
            Updater which sets the particle's color to a fixed value sampled based on the particle's normalized life value
            </summary>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterColorOverTime.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterColorOverTime.IsPostUpdater">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterColorOverTime.SamplerMain">
            <summary>
            The main curve sampler. Particles will change their value based on the sampled values
            </summary>
            <userdoc>
            The main curve sampler. Particles will change their value based on the sampled values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterColorOverTime.SamplerOptional">
            <summary>
            Optional sampler. If present, particles will pick a random value between the two sampled curves
            </summary>
            <userdoc>
            Optional sampler. If present, particles will pick a random value between the two sampled curves
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterColorOverTime.SeedOffset">
            <summary>
            Seed offset. You can use this offset to bind the randomness to other random values, or to make them completely unrelated
            </summary>
            <userdoc>
            Seed offset. You can use this offset to bind the randomness to other random values, or to make them completely unrelated
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterColorOverTime.PreUpdate">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterColorOverTime.Update(System.Single,Stride.Particles.ParticlePool)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterColorOverTime.UpdateSingleSampler(Stride.Particles.ParticlePool)">
            <summary>
            Updates the field by sampling a single value over the particle's lifetime
            </summary>
            <param name="pool">Target <see cref="T:Stride.Particles.ParticlePool"/></param>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterColorOverTime.UpdateDoubleSampler(Stride.Particles.ParticlePool)">
            <summary>
            Updates the field by interpolating between two sampled values over the particle's lifetime
            </summary>
            <param name="pool">Target <see cref="T:Stride.Particles.ParticlePool"/></param>
        </member>
        <member name="T:Stride.Particles.Updaters.UpdaterRotationOverTime">
            <summary>
            Updater which sets the particle's size to a fixed value sampled based on the particle's normalized life value
            </summary>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterRotationOverTime.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterRotationOverTime.IsPostUpdater">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterRotationOverTime.SamplerMain">
            <summary>
            The main curve sampler. Particles will change their value based on the sampled values
            </summary>
            <userdoc>
            The main curve sampler. Particles will change their value based on the sampled values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterRotationOverTime.SamplerOptional">
            <summary>
            Optional sampler. If present, particles will pick a random value between the two sampled curves
            </summary>
            <userdoc>
            Optional sampler. If present, particles will pick a random value between the two sampled curves
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterRotationOverTime.SeedOffset">
            <summary>
            Seed offset. You can use this offset to bind the randomness to other random values, or to make them completely unrelated
            </summary>
            <userdoc>
            Seed offset. You can use this offset to bind the randomness to other random values, or to make them completely unrelated
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterRotationOverTime.PreUpdate">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterRotationOverTime.Update(System.Single,Stride.Particles.ParticlePool)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterRotationOverTime.UpdateSingleSampler(Stride.Particles.ParticlePool)">
            <summary>
            Updates the field by sampling a single value over the particle's lifetime
            </summary>
            <param name="pool">Target <see cref="T:Stride.Particles.ParticlePool"/></param>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterRotationOverTime.UpdateDoubleSampler(Stride.Particles.ParticlePool)">
            <summary>
            Updates the field by interpolating between two sampled values over the particle's lifetime
            </summary>
            <param name="pool">Target <see cref="T:Stride.Particles.ParticlePool"/></param>
        </member>
        <member name="T:Stride.Particles.Updaters.UpdaterSizeOverTime">
            <summary>
            Updater which sets the particle's size to a fixed value sampled based on the particle's normalized life value
            </summary>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterSizeOverTime.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterSizeOverTime.IsPostUpdater">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterSizeOverTime.SamplerMain">
            <summary>
            The main curve sampler. Particles will change their value based on the sampled values
            </summary>
            <userdoc>
            The main curve sampler. Particles will change their value based on the sampled values
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterSizeOverTime.SamplerOptional">
            <summary>
            Optional sampler. If present, particles will pick a random value between the two sampled curves
            </summary>
            <userdoc>
            Optional sampler. If present, particles will pick a random value between the two sampled curves
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Updaters.UpdaterSizeOverTime.SeedOffset">
            <summary>
            Seed offset. You can use this offset to bind the randomness to other random values, or to make them completely unrelated
            </summary>
            <userdoc>
            Seed offset. You can use this offset to bind the randomness to other random values, or to make them completely unrelated
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterSizeOverTime.PreUpdate">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterSizeOverTime.Update(System.Single,Stride.Particles.ParticlePool)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterSizeOverTime.UpdateSingleSampler(Stride.Particles.ParticlePool)">
            <summary>
            Updates the field by sampling a single value over the particle's lifetime
            </summary>
            <param name="pool">Target <see cref="T:Stride.Particles.ParticlePool"/></param>
        </member>
        <member name="M:Stride.Particles.Updaters.UpdaterSizeOverTime.UpdateDoubleSampler(Stride.Particles.ParticlePool)">
            <summary>
            Updates the field by interpolating between two sampled values over the particle's lifetime
            </summary>
            <param name="pool">Target <see cref="T:Stride.Particles.ParticlePool"/></param>
        </member>
        <member name="T:Stride.Particles.Modules.ParticleUpdater">
            <summary>
            The <see cref="T:Stride.Particles.Modules.ParticleUpdater"/> updates one or more fields, such as velocity or position, in all living particles in a target <see cref="T:Stride.Particles.ParticlePool"/>
            </summary>
        </member>
        <member name="P:Stride.Particles.Modules.ParticleUpdater.IsPostUpdater">
            <summary>
            All updaters are called exactly once during each <see cref="T:Stride.Particles.ParticleEmitter"/>'s update.
            Most updaters are called before spawning the new particles for the frame, but post updaters are called after that.
            </summary>
            <userdoc>
            Most updaters are called before spawning the new particles for the frame, but post updaters are called after that.
            This is important when the updater needs to verify a value even after it was initialized for the first time.
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Modules.ParticleUpdater.Update(System.Single,Stride.Particles.ParticlePool)">
            <summary>
            Updates all particles in the <see cref="T:Stride.Particles.ParticlePool"/> using this updater
            </summary>
            <param name="dt">Delta time in seconds which has passed since the last update call</param>
            <param name="pool">The target <see cref="T:Stride.Particles.ParticlePool"/> which needs to be updated</param>
        </member>
        <member name="T:Stride.Particles.Modules.UpdaterCollider">
            <summary>
            The <see cref="T:Stride.Particles.Modules.UpdaterCollider"/> is an updater which tests the particles against a preset surface or shape, making them bounce off it when they collide
            </summary>
        </member>
        <member name="M:Stride.Particles.Modules.UpdaterCollider.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterCollider.IsPostUpdater">
            <inheritdoc/>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterCollider.FieldShape">
            <summary>
            The type of the shape which defines this collider
            </summary>
            <userdoc>
            The type of the shape which defines this collider
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterCollider.IsHollow">
            <summary>
            Shows if the collider shape is hollow on the inside or solid
            </summary>
            <userdoc>
            If the collider shape is hollow, particles can't escape it.
            If the collider shape is solid, particles can't enter the shape.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterCollider.KillParticles">
            <summary>
            Kill particles when they collide with the shape
            </summary>
            <userdoc>
            Kill particles when they collide with the shape
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterCollider.Restitution">
            <summary>
            How much of the vertical (normal-oriented) kinetic energy is preserved after impact
            </summary>
            <userdoc>
            How much of the vertical (normal-oriented) kinetic energy is preserved after impact.
            Restitution here only affects vertical velocity (perpendicular to the surface).
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterCollider.Friction">
            <summary>
            How much of the horizontal (normal-perpendicular) kinetic energy is lost after impact
            </summary>
            <userdoc>
            How much of the horizontal (normal-perpendicular) kinetic energy is lost after impact
            Friction here only affects horizonal velocity (along the surface).
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Modules.UpdaterCollider.Update(System.Single,Stride.Particles.ParticlePool)">
            <inheritdoc/>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterCollider.DebugDraw">
            <summary>
            Should this Particle Module's bounds be displayed as a debug draw
            </summary>
            <userdoc>
            Display the Particle Module's bounds as a wireframe debug shape. Temporary feature (will be removed later)!
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Modules.UpdaterCollider.TryGetDebugDrawShape(Stride.Particles.DebugDraw.DebugDrawShape@,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,Stride.Core.Mathematics.Vector3@)">
            <inheritdoc/>
        </member>
        <member name="T:Stride.Particles.Modules.UpdaterForceField">
            <summary>
            The <see cref="T:Stride.Particles.Modules.UpdaterForceField"/> updates the particles' positions and velocity based on proximity and relative position to a bounding force field
            </summary>
        </member>
        <member name="M:Stride.Particles.Modules.UpdaterForceField.#ctor">
            <summary>
            Default constructor which also registers the fields required by this updater
            </summary>
        </member>
        <member name="F:Stride.Particles.Modules.UpdaterForceField.parentScale">
            <summary>
            Shows how much the force vector should scale when the bounding box also scales
            </summary>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.FieldShape">
            <summary>
            The shape defines the force field's bounding shape, which influences the force vectors and magnitude for every given particle
            </summary>
            <userdoc>
            The shape defines the force field's bounding shape, which influences the force vectors and magnitude for every given particle
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.FieldFalloff">
            <summary>
            Defines how and if the total magnitude of the force should change depending of how far away the particle is from the central axis
            </summary>
            <userdoc>
            Defines how and if the total magnitude of the force should change depending of how far away the particle is from the central axis
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.EnergyConservation">
            <summary>
            How much of the force should be applied as conserved energy (acceleration)
            </summary>
            <userdoc>
            With no concervation (0) particles will cease to move when the force disappears (physically incorrect, but easier to control).
            With energy concervation (1) particles will retain energy and gradually accelerate, continuing to move even when the force
            cease to exist (physically correct, but more difficult to control).
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.ForceDirected">
            <summary>
            The force ALONG the bounding shape's axis.
            </summary>
            <userdoc>
            The force ALONG the bounding shape's axis.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.ForceVortex">
            <summary>
            The force AROUND the bounding shape's axis.
            </summary>
            <userdoc>
            The force AROUND the bounding shape's axis.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.ForceRepulsive">
            <summary>
            The force AWAY from the bounding shape's axis.
            </summary>
            <userdoc>
            The force AWAY from the bounding shape's axis.
            </userdoc>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.ForceFixed">
            <summary>
            The fixed force doesn't scale or rotate with the the bounding shape
            </summary>
            <userdoc>
            The fixed force doesn't scale or rotate with the the bounding shape
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Modules.UpdaterForceField.Update(System.Single,Stride.Particles.ParticlePool)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.Modules.UpdaterForceField.SetParentTRS(Stride.Particles.ParticleTransform,Stride.Particles.ParticleSystem)">
            <inheritdoc />
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterForceField.DebugDraw">
            <summary>
            Should this Particle Module's bounds be displayed as a debug draw
            </summary>
            <userdoc>
            Display the Particle Module's bounds as a wireframe debug shape. Temporary feature (will be removed later)!
            </userdoc>
        </member>
        <member name="M:Stride.Particles.Modules.UpdaterForceField.TryGetDebugDrawShape(Stride.Particles.DebugDraw.DebugDrawShape@,Stride.Core.Mathematics.Vector3@,Stride.Core.Mathematics.Quaternion@,Stride.Core.Mathematics.Vector3@)">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.Modules.UpdaterGravity">
            <summary>
            The <see cref="T:Stride.Particles.Modules.UpdaterGravity"/> is a simple version of a force field which updates the particles' velocity over time and acts as a gravitational force
            </summary>
        </member>
        <member name="F:Stride.Particles.Modules.UpdaterGravity.GravitationalAcceleration">
            <summary>
            Direction and magnitude of the gravitational acceleration
            </summary>
        </member>
        <member name="T:Stride.Particles.Modules.UpdaterSpeedToDirection">
            <summary>
            The <see cref="T:Stride.Particles.Modules.UpdaterSpeedToDirection"/> calculates the particle's direction (not normalized) based on its delta position
            </summary>
        </member>
        <member name="P:Stride.Particles.Modules.UpdaterSpeedToDirection.IsPostUpdater">
            <inheritdoc />
        </member>
        <member name="T:Stride.Particles.VertexLayouts.AttributeAccessor">
            <summary>
            <see cref="T:Stride.Particles.VertexLayouts.AttributeAccessor"/> is use to access and modify a particle vertex attribute.
            </summary>
        </member>
        <member name="F:Stride.Particles.VertexLayouts.AttributeAccessor.Offset">
            <summary>
            Offset of the attribute from the beginning of the vertex position
            </summary>
        </member>
        <member name="F:Stride.Particles.VertexLayouts.AttributeAccessor.Size">
            <summary>
            Size of the attribute field
            </summary>
        </member>
        <member name="T:Stride.Particles.VertexLayouts.AttributeDescription">
            <summary>
            Attribute description code used for defining vertex attributes in the <see cref="T:Stride.Particles.VertexLayouts.ParticleVertexBuilder"/>
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.AttributeDescription.Equals(Stride.Particles.VertexLayouts.AttributeDescription)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.VertexLayouts.AttributeDescription.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.VertexLayouts.AttributeDescription.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.SetVerticesPerSegment(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets how many vertices are associated with the first, middle and last quad segments of the buffer. In case of billboards 1 segment = 1 quad but other shapes might be laid out differently
            </summary>
            <param name="verticesForFirstSegment">Number of vertices for the first segment</param>
            <param name="verticesForMiddleSegment">Number of vertices for the middle segments</param>
            <param name="verticesForLastSegment">Number of vertices for the last segment</param>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.SetAttribute(Stride.Particles.VertexLayouts.AttributeAccessor,System.IntPtr)">
            <summary>
            Sets the data for the current vertex using the provided <see cref="T:Stride.Particles.VertexLayouts.AttributeAccessor"/>
            </summary>
            <param name="accessor">Accessor to the vertex data</param>
            <param name="ptrRef">Pointer to the source data</param>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.SetAttributePerParticle(Stride.Particles.VertexLayouts.AttributeAccessor,System.IntPtr)">
            <summary>
            Sets the same data for the all vertices in the current particle using the provided <see cref="T:Stride.Particles.VertexLayouts.AttributeAccessor"/>
            </summary>
            <param name="accessor">Accessor to the vertex data</param>
            <param name="ptrRef">Pointer to the source data</param>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.SetAttributePerSegment(Stride.Particles.VertexLayouts.AttributeAccessor,System.IntPtr)">
            <summary>
            Sets the same data for the all vertices in the current particle using the provided <see cref="T:Stride.Particles.VertexLayouts.AttributeAccessor"/>
            </summary>
            <param name="accessor">Accessor to the vertex data</param>
            <param name="ptrRef">Pointer to the source data</param>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.TransformAttributePerSegment``2(Stride.Particles.VertexLayouts.AttributeAccessor,Stride.Particles.VertexLayouts.AttributeAccessor,Stride.Particles.VertexLayouts.IAttributeTransformer{``0,``1},``1@)">
            <summary>
            Transforms attribute data using already written data from another attribute
            </summary>
            <typeparam name="T">Type data</typeparam>
            <param name="accessorTo">Vertex attribute accessor to the destination attribute</param>
            <param name="accessorFrom">Vertex attribute accessor to the source attribute</param>
            <param name="transformMethod">Transform method for the type data</param>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.NextVertex">
            <summary>
            Advances the pointer to the next vertex in the buffer, so that it can be written
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.NextParticle">
            <summary>
            Advances the pointer to the next particle in the buffer, so that its first vertex can be written
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.NextSegment">
            <summary>
            Advances the pointer to the next segment in the buffer, so that its first vertex can be written
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleBufferState.StartOver">
            <summary>
            Moves the index to the beginning of the buffer so that the data can be filled from the first particle again
            </summary>
        </member>
        <member name="T:Stride.Particles.VertexLayouts.ParticleVertexBuilder">
            <summary>
            Manager class for the vertex buffer stream which can dynamically change the required vertex layout and rebuild the buffer based on the particle fields
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleVertexBuilder.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Stride.Particles.VertexLayouts.ParticleVertexBuilder.VertexDeclaration">
            <summary>
            The current <see cref="T:Stride.Graphics.VertexDeclaration"/> of the contained vertex buffer
            </summary>
        </member>
        <member name="P:Stride.Particles.VertexLayouts.ParticleVertexBuilder.VertexCount">
            <summary>
            The current number of vertices which have to be drawn
            </summary>
        </member>
        <member name="P:Stride.Particles.VertexLayouts.ParticleVertexBuilder.DefaultTexCoords">
            <summary>
            The default texture coordinates will default to the first texture coordinates element added to the list in case there are two or more sets
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleVertexBuilder.ResetVertexElementList">
            <summary>
            Resets the list of required vertex elements, setting it to the minimum mandatory length
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleVertexBuilder.AddVertexElement(Stride.Graphics.VertexElement)">
            <summary>
            Adds a new required element to the list of vertex elements, if it's not in the list already
            </summary>
            <param name="element">New element to add</param>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleVertexBuilder.UpdateVertexLayout">
            <summary>
            Updates the vertex layout with the new list. Should be called only when there have been changes to the list.
            </summary>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleVertexBuilder.SetRequiredQuads(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the required quads per particle and number of particles so that a sufficiently big buffer can be allocated
            </summary>
            <param name="quadsPerParticle">Required quads per particle, assuming 1 quad = 4 vertices = 6 indices</param>
            <param name="livingParticles">Number of living particles this frame</param>
            <param name="totalParticles">Number of total number of possible particles for the parent emitter</param>
        </member>
        <member name="M:Stride.Particles.VertexLayouts.ParticleVertexBuilder.Reset">
            <summary>
            Resets the <see cref="T:Stride.Particles.VertexLayouts.ParticleVertexBuilder"/> to its initial state, freeing any graphics memory used
            </summary>
        </member>
        <member name="T:Stride.Particles.VertexLayouts.ParticleVertexElements">
            <summary>
            A list of common <see cref="T:Stride.Graphics.VertexElement"/> used in the particles' vertex layout
            </summary>
        </member>
        <member name="T:Stride.Particles.VertexLayouts.VertexAttributes">
            <summary>
            A list of common <see cref="T:Stride.Particles.VertexLayouts.AttributeDescription"/> used to access the vertex fileds in a <see cref="T:Stride.Particles.VertexLayouts.ParticleVertexBuilder"/>
            </summary>
        </member>
        <member name="T:Stride.StrideVersion">
            <summary>
            Internal version used to identify Stride version.
            </summary>
            <remarks>
            During package build, PackageUpdateVersionTask is updating that file and expect some specific text regex so be careful if you change any of this.
            </remarks>
        </member>
        <member name="F:Stride.StrideVersion.PublicVersion">
            <summary>
            The version used by editor for display purpose. 4th digit needs to be at least 1 if used (due to NuGet special cases).
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.AssemblyVersion">
            <summary>
            The current assembly version as text, currently same as <see cref="F:Stride.StrideVersion.PublicVersion"/>.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.NuGetVersionSimple">
            <summary>
            The NuGet package version without special tags.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.NuGetVersion">
            <summary>
            The NuGet package version.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.NuGetVersionSuffix">
            <summary>
            The NuGet package suffix (i.e. -beta01). Automatically set by Stride.GitVersioning.GenerateVersionFile.
            Three possible values:
            - Empty: official release
            - -betaXX: development version (XX should corespond to development asset versioning)
            - -betaXX-YYYY: beta release (YYYY is the git height since current version has been bumped)
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.BuildMetadata">
            <summary>
            The build metadata, usually +g[git_hash] during package. Automatically set by Stride.GitVersioning.GenerateVersionFile.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.AssemblyInformationalVersion">
            <summary>
            The informational assembly version, containing -beta01 or +g[git_hash] during package.
            </summary>
        </member>
        <member name="T:Stride.PublicKeys">
            <summary>
            Assembly signing information.
            </summary>
        </member>
        <member name="F:Stride.PublicKeys.Default">
            <summary>
            Assembly name suffix that contains signing information.
            </summary>
        </member>
    </members>
</doc>
